Package org.jrdf.sparql.parser;

/*
 * SPARQL Query Language for RDF (SableCC grammar)
 * $Id$
 */

Helpers
  character  = [0..0xFFFF];
  letter     = ['a'..'z'] | ['A'..'Z'];
  digit      = ['0'..'9'];
  tab        = 9;
  lf         = 10;
  cr         = 13;
  sl         = 47;
  whitespace = ' ' | tab | lf | cr;
  nonblank   = [33..126];
  nonquote   = [character - [39 + '\']];
  nonslash   = [[33..126] - sl];
  urlchar    = [character - '>'];

States
  def,  /* default state */
  com,  /* comment */
  esc,  /* escaping character in quoted literal with '\' */
  lit,  /* quoted literal */
  res,  /* tagged resource */
  var;  /* escaping variable name with '?' or '$' */

Tokens
  {def}                select      = ('SELECT' | 'select');
  {def}                where       = ('WHERE' | 'where');

  {def, var->def}      identifier = letter (letter | digit | '_' | '$' | '?' )*;
  {def}                blank          = whitespace+;
  {def->com}           hash           = '#';
  {com}                comment        = [character - [lf + cr]];
  {com->def}           endcomment     = (lf | cr)+;
  {def}                terminator     = ';';
  {def}                lpar           = '{';
  {def}                rpar           = '}';
  {def->res}           url            = '<';
  {res->def}           endurl         = '>';
  {def}                datatypeprefix = '^^';
  {def->var}           variableprefix = ('?' | '$');
  {def}                full_stop  =
  {def}                number     = digit+;
  {def}                float      = digit+ ('.' digit*) | ('.' digit+);
  {def{                asterisk   = '*';

  {res}                resource    = urlchar*;
  {def->lit, lit->def} quote       = 39;  /* ' */
  {lit->esc}           escape      = '\';
  {esc->lit}           escapedtext = character;
  {lit}                text        = nonquote+;

Ignored Tokens
  blank, comment, escape, endcomment, endurl, hash, url;

Productions
  start =
    {query} select_clause where_clause?;

  select_clause =
    /*{graph_pattern} select element+ |*/
    {wildcard} select asterisk ;

  where_clause =
    where? graph_pattern;

  graph_pattern =
    lpar pattern_elements_list rpar ;

  patter_elements_list =
    pattern_element pattern_elements_list_tail? ;

  pattern_elements_list_tail =
    full_stop patter_elements_list? ;


    [subject]:element [predicate]:element [object]:element ;



  triple =
    [subject]:triple_element [predicate]:triple_element [object]:triple_element ;

  triple_element =
    {resource} resource |
    {literal}  literal  |
    {variable} variable ;



  graph_pattern_term =
    {dterm}  graph_pattern_dterm                     |
    {and}    graph_pattern_term and graph_pattern_dterm ;

  graph_pattern_dterm =
    {factor} graph_pattern_factor |
    {minus} [minuend]:graph_pattern_dterm minus [subtrahend]:graph_pattern_factor ;

  graph_pattern_factor =
    {graph_pattern} exclude? graph_pattern                  |
    {expression} exclude? lpar graph_pattern_expression rpar |
    {transitive} transitive_clause |
    {walk} walk_clause ;

  transitive_clause =
    {transitive1} trans lpar graph_pattern rpar |
    {transitive2} trans lpar [graph_pattern1]:graph_pattern and [graph_pattern2]:graph_pattern rpar ;

  walk_clause =
    {walk1} walk lpar [graph_pattern1]:graph_pattern and [graph_pattern2]:graph_pattern rpar;

  order_clause =
    order by order_element+ ;

  order_element =
    variable direction ;

  direction =
    {ascending}  asc? |
    {descending} desc ;

  limit_clause =
    limit number;

  offset_clause =
    offset number;


  aggregate =
    {count}    count    |
    {subquery} subquery ;

  literal =
    [opening]:quote strand* [closing]:quote datatype?;

  strand =
    {unescaped} text |
    {escaped}   escapedtext;

  datatype =
    datatypeprefix resource;

  variable =
    variableprefix identifier;

  locality =
    {local} local |
    {remote} remote ;

