<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/transitional.dtd"><html>
<head>

  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"/>
  <title>A Relational View of the Semantic Web</title>


</head>


<body>

<h1>A Relational View of the Semantic Web</h1>

<p>Resource Description Framework (RDF) and other Semantic Web
Activities have a lot in common with popularized efforts such as those
recently labeled as &ldquo;Web 2.0&rdquo;.&nbsp; These
efforts
are largely concerned with allowing communities to share and reuse
data.&nbsp; In this way the
Semantic Web and Web 2.0 can both be seen as attempts at providing data
integration and
presenting a web of data or information space.&nbsp; As Tim
Berners-Lee wrote in &ldquo;Weaving the
Web&rdquo; [1]:</p>

<p style="margin-left: 36pt;"><i style="">&ldquo;If
HTML and the Web made all the online
documents look like on huge book, RDF, schema and inference languages
will make all the data in the
world look like one huge database.&rdquo;</i>&nbsp;
</p>

<p>RDF is at the core of W3C&rsquo;s Semantic Web
architectural layers. It is the standard specifically designed to
provide a way to
produce and consume data on the Web.&nbsp; It sits on top of
standards such as XML, URIs and Unicode and is used as a basis for
schemas and ontologies.&nbsp; It consists of a set of statements
that are composed of a subject, predicate and object that form
propositions of fact [7].</p>

<p>How are queries performed on this &ldquo;one huge
database&rdquo;?&nbsp;
Up until recently, manipulating or retrieving RDF data has been done
through vendor specific query languages or imperatively through APIs in
languages such as Java, PHP and Ruby.&nbsp; The W3C&rsquo;s
proposed standard, SPARQL, is
set to provide a declarative language to query and manipulate Semantic
Web
data [8].</p>

<p>SPARQL consists of operations that are reasonably similar to
those found in existing and mature technologies such SQL or relational
algebra including: join, union, left outer join (SPARQL&rsquo;s
OPTIONAL), and comparison operators (SPARQL&rsquo;s FILTER) such as
equal to,
less than, greater than, etc [8].&nbsp; </p>

<p>The current suite of existing technologies, such as SQL and
the relational model, were devised without the specific requirements of
disparate, uncontrolled, large-scale integration.&nbsp;
It is unclear whether they are flexible enough to adapt to these new
set of requirements in order to enable this idea of a global database.</p>

<h2>Advantages of Loose Structure</h2>

<p>Before attempting to defined SPARQL
and RDF in relational
terms it&rsquo;s useful to explore some of the reasons why storing
data in this
manner might be chosen.</p>

<p>One of the difficulties in creating
this shared information space is to agree on a schema for the data to
be stored in.&nbsp;
Traditionally, before anyone could put share data everyone would have
to agree on the schema and then they
could start storing and querying the data.&nbsp; One
of the great strengths of the RDF model is to allow data to be stored
and query data without first requiring a schema.&nbsp;
This decoupling of schema and data also allows the schema to change
independently of the data without requiring any existing data to be
thrown away or padded with NULLs.&nbsp; It also allows a schema to
be automatically generated by importing the instance
data as the initial basis of a ontology.</p>

<p>It also allows database design and
management to be much
more agile, similar to agile software development, where a schema can
be
designed incrementally, after the data has been collected and it can
evolve
over time, as new requirements are encountered. It allows data that is
structured slightly differently to be stored together in the lowest
common
denominator of an RDF statement (subject, predicate and
object).&nbsp; It eliminates the decision
to weigh up
good design against performance in order to store data that might be
slightly
different in structure.&nbsp; For
example, it allows suppliers without cities and names to be stored
along with
those that do.</p>

<p>This lack of padding, of not needing
NULLs, removes one of
the most debated topics in SQL and the relational model&rsquo;s use
of it (see &ldquo;Much
Ado About Nothing&rdquo; [5]).&nbsp;
The
argument has generally revolved around the possible confusing uses of
NULLs and
what a NULL value actually means.&nbsp;
This becomes especially important when one of the main
tasks of the
Semantic Web is integrating data from many different sources.&nbsp;
A NULL value can mean
different things
from different data sources and may have been produced as a result of
different
types of queries.&nbsp; This
lack of
context, which is often lost in traditional databases too, means it
becomes
prohibitively costly and difficult to retain the specific meaning of
NULL values
from across the wide variety of sources available on the Semantic Web.</p>

<p>Removing the use of NULLs also has a
positive impact when
considering the inconsistent handling that occurs across various SQL
database
implementations.&nbsp; It
can also
simplify aggregate functions where a NULL value is considered when
counting
rows but not when performing other operations such as averaging values.</p>

<h2>RDF using the Relational Model</h2>

<p>An RDF statement or proposition seems
fairly abstract but it
is actually familiar to most developers in the form of database
management
systems (DBMS) and the most popular relational language SQL.&nbsp;
These databases provide a
way to
represent statements of facts or propositions and to ask questions
(queries) as
to whether a given proposition is true or not.</p>

<p>For the purposes of storing
propositions and answering
queries its possible to represent RDF in an SQL or relational database
and vice
versa.&nbsp; The
advantage in storing RDF
using these previous models is to allow previous work done such as
formalizing
query operations and query optimisation to be applied to SPARQL.</p>

<p>It should be made clear that the work
conducted here does
not concern itself with specific ways of storing RDF but merely using
previous
models as examples of what can be applied to RDF.&nbsp;
There are many different approaches to
creating efficient RDF stores including more efficient table
structures,
manipulating RDF data so that it can be stored more efficiently, and
creating
databases (not based on SQL) specifically designed to efficiently store
RDF
(which is narrow, regular and requires many joins).</p>

<p>In order to describe a relational
model of RDF a familiar
example is used throughout: the supplier and parts tables as used by
C.J Date
[4].&nbsp; Figure 1 shows
a typical set
of data from the supplier table.&nbsp; It
consists of a table heading, where the columns (or attributes) consist
of a
name and type, and a body that consists of rows with values for each of
these
columns.&nbsp;&nbsp; The
first row of the
body in Figure 1 is a proposition that represents, &ldquo;A
supplier &lsquo;S1&rsquo;, has a name
called &lsquo;Smith&rsquo;, a status of
&lsquo;20&rsquo; and a city of
&lsquo;London&rsquo;&rdquo;. </p>

<table border="1">
  <tbody>
    <tr>
      <td valign="top">
      <p>SNO</p>
      </td>
      <td valign="top">
      <p>sno</p>
      </td>
      <td valign="top">
      <p>SNAME</p>
      </td>
      <td valign="top">
      <p>name</p>
      </td>
      <td valign="top">
      <p>STATUS</p>
      </td>
      <td valign="top">
      <p>integer</p>
      </td>
      <td valign="top">
      <p>CITY</p>
      </td>
      <td valign="top">
      <p>char</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S1</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Smith&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>20</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;London&rdquo;</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S2</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Jones&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>10</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Paris&rdquo;</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S3</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Blake&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>30</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Paris&rdquo;</p>
      </td>
    </tr>
  </tbody>
</table>

<p>Figure 1 Example of a Supplier Table</p>

<p>Figure 2 shows the mapping of this
data (containing the same
propositions) represented as an RDF graph.&nbsp;
This representation takes the table headings (columns) as
arrows to
connect the values and their data types to an identifier
(&ldquo;_1&rdquo;, &ldquo;_2&rdquo;,
&ldquo;_3&rdquo;).&nbsp; These
are RDF identifiers,
called blank nodes, which are a placeholder for the other properties
and values
to be associated to one another, similar to a table row.&nbsp; The
blank nodes represent
the existence
of a supplier but do not describe any properties of the
supplier.&nbsp; </p>

<p><img src="image002.jpg" alt="Example of a Supplier Graph" height="353" width="569"/></p>

<p>Figure 2 Example of a Supplier Graph</p>

<p>An alternative mapping could take a primary key (SNO is a
likely
candidate) as being the centre of all the values.&nbsp; However,
this
limits the possibility of representing suppliers without a known
supplier number or duplicate rows (ones that typically occur in SQL
tables that don&rsquo;t have uniqueness constraints
applied).&nbsp;
Representing a supplier without a required attribute may not seem
initially sensible for those used to creating data models in closed
environments.&nbsp; However, on the Web or any large distributed
system, agreement of what is a required attribute may not be able to be
reached ahead of time or perhaps an authority required to create unique
identifiers may not be reachable at the time the data is
stored.&nbsp;
Similarly, detecting duplicates is something that may have to occur
after the data is recorded.</p>

<p>This choice between a blank node or unique identifier is
similar to
the surrogate vs. natural key in relational databases.&nbsp; The
difference is that blank nodes cannot be searched on by value in the
same way a numeric surrogate key can.&nbsp; The advantage is that
blank
nodes can be created locally and distributed globally without requiring
an authority to generate them. </p>

<p>An RDF graph is a lot less structured
than the given typical
relational table, but it still has a fixed structure of the RDF
statement
(subject, predicate and object).&nbsp; As
this structure is fixed it&rsquo;s therefore possible to represent
it
relationally.&nbsp; This
is given in
Figure 3 using the data represented in Figures 1 and 2. </p>

<table border="1">
  <tbody>
    <tr>
      <td valign="top">
      <p>s1</p>
      </td>
      <td valign="top">
      <p>subject</p>
      </td>
      <td valign="top">
      <p>p1</p>
      </td>
      <td valign="top">
      <p>predicate</p>
      </td>
      <td valign="top">
      <p>o1</p>
      </td>
      <td valign="top">
      <p>Object</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>_1</p>
      </td>
      <td colspan="2" valign="top">
      <p>#sno</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;S1&rdquo;^^#sno</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>_1</p>
      </td>
      <td colspan="2" valign="top">
      <p>#sname</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Smith&rdquo;^^#name</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>_1</p>
      </td>
      <td colspan="2" valign="top">
      <p>#status</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;20&rdquo;^^#integer</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>_1</p>
      </td>
      <td colspan="2" valign="top">
      <p>#city</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;London&rdquo;^^#char</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>_2</p>
      </td>
      <td colspan="2" valign="top">
      <p>#sno</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;S2&rdquo;^^#sno</p>
      </td>
    </tr>
    <tr style="">
      <td colspan="2" valign="top">
      <p>_2</p>
      </td>
      <td colspan="2" valign="top">
      <p>#sname</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Jones&rdquo;^^#name</p>
      </td>
    </tr>
    <tr style="">
      <td colspan="2" valign="top">
      <p>_2</p>
      </td>
      <td colspan="2" valign="top">
      <p>#status</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;10&rdquo;^^#integer</p>
      </td>
    </tr>
    <tr style="">
      <td colspan="2" valign="top">
      <p>_2</p>
      </td>
      <td colspan="2" valign="top">
      <p>#city</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Paris&rdquo;^^#char</p>
      </td>
    </tr>
    <tr style="">
      <td colspan="2" valign="top">
      <p>_3</p>
      </td>
      <td colspan="2" valign="top">
      <p>#sno</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;S3&rdquo;^^#sno</p>
      </td>
    </tr>
    <tr style="">
      <td colspan="2" valign="top">
      <p>_3</p>
      </td>
      <td colspan="2" valign="top">
      <p>#sname</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Jones&rdquo;^^name</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>_3</p>
      </td>
      <td colspan="2" valign="top">
      <p>#status</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;30&rdquo;^^#integer</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>_3</p>
      </td>
      <td colspan="2" valign="top">
      <p>#city</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Paris&rdquo;^^#char</p>
      </td>
    </tr>
  </tbody>
</table>

<p>Figure 3 The Supplier Data as RDF Triples in a Relation</p>

<p>The types of the columns are
RDF&rsquo;s node types: subject,
predicate and object and are named &ldquo;s1&rdquo;,
&ldquo;p1&rdquo; and &ldquo;o1&rdquo;
respectively.&nbsp; An RDF subject can be a
blank node or
URI, a predicate a URI and an object can be a URI, blank node or
literal. The
use of hashes (&ldquo;#&rdquo;) is merely a convention used to
represent URIs with a
namespace that is unimportant and literal values are composed of a
value and a
datatype (which are also URIs) that is preceded by two carets
(&ldquo;^^&rdquo;).&nbsp; So
the literals &ldquo;Smith&rdquo; and &ldquo;20&rdquo;
are of
type &ldquo;name&rdquo; and &ldquo;integer&rdquo;
respectively.</p>

<p>This view of RDF as a relational
structure is not that
unique and was described in the early stages of RDF&rsquo;s
development by Tim
Berners-Lee [2].</p>

<h2>RDF without NULL</h2>

<p>RDF does not have the concept of a
NULL value.&nbsp; Similarly,
the relational model as
defined by Date dismisses the need for a NULL value too.&nbsp; RDF
can be stored using
this version of
the relational model and hence NULL values can successfully in its
representation.</p>

<p>This is best demonstrated by looking
at the data from Figure
3 and considering what if supplier S2 and S3 didn&rsquo;t have a
status and S3 also
lacked a city. What would a flexible view be of the data look like if
you
didn&rsquo;t need to worry about agreeing on one table structure
and didn&rsquo;t use
NULLs?&nbsp; Figure 4, 5
and 6 shows
three relations each with a different number of columns (different
types) and
Figure 7 shows the merging of these relations into one, as an untyped
relation.
An untyped relation is a relation that contains a set of tuples that
can
contain a subset of values bound to the heading&rsquo;s
attributes.&nbsp; To return the untyped
relation to a
typed relation a simple project on the required columns can be
performed.&nbsp; There
are no NULLs &ndash; there are tuples
that contain sets of values that are unbound or don&rsquo;t return
a value for the
given column (attribute).</p>

<table border="1">
  <tbody>
    <tr>
      <td valign="top">
      <p>SNO</p>
      </td>
      <td valign="top">
      <p>sno</p>
      </td>
      <td valign="top">
      <p>SNAME</p>
      </td>
      <td valign="top">
      <p>Name</p>
      </td>
      <td valign="top">
      <p>STATUS</p>
      </td>
      <td valign="top">
      <p>Integer</p>
      </td>
      <td valign="top">
      <p>CITY</p>
      </td>
      <td valign="top">
      <p>char</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S1</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Smith&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>20</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;London&rdquo;</p>
      </td>
    </tr>
  </tbody>
</table>
<p>Figure 4 Suppliers with a name, status and city.</p>
<table border="1">
  <tbody>
    <tr>
      <td valign="top">
      <p>SNO</p>
      </td>
      <td valign="top">
      <p>sno</p>
      </td>
      <td valign="top">
      <p>SNAME</p>
      </td>
      <td valign="top">
      <p>name</p>
      </td>
      <td valign="top">
      <p>STATUS</p>
      </td>
      <td valign="top">
      <p>integer</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S1</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Smith&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>20</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S2</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Jones&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>10</p>
      </td>
    </tr>
  </tbody>
</table>

<p>Figure 5 Suppliers with a name and status.</p>

<table border="1">
  <tbody>
    <tr>
      <td valign="top">
      <p>SNO</p>
      </td>
      <td valign="top">
      <p>sno</p>
      </td>
      <td valign="top">
      <p>SNAME</p>
      </td>
      <td valign="top">
      <p>name</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S1</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Smith&rdquo;</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S2</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Jones&rdquo;</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S3</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Blake&rdquo;</p>
      </td>
    </tr>
  </tbody>
</table>

<p>Figure 6 Suppliers with a name.</p>

<table border="1">
  <tbody>
    <tr>
      <td valign="top">
      <p>SNO</p>
      </td>
      <td valign="top">
      <p>sno</p>
      </td>
      <td valign="top">
      <p>SNAME</p>
      </td>
      <td valign="top">
      <p>name</p>
      </td>
      <td valign="top">
      <p>STATUS</p>
      </td>
      <td valign="top">
      <p>integer</p>
      </td>
      <td valign="top">
      <p>CITY</p>
      </td>
      <td valign="top">
      <p>char</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S1</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Smith&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>20</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;London&rdquo;</p>
      </td>
    </tr>
    <tr style="height: 20.9pt;">
      <td colspan="2" valign="top">
      <p>S2</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Jones&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>10</p>
      </td>
      <td colspan="2" valign="top">&nbsp;</td>
    </tr>
    <tr style="height: 20.9pt;">
      <td colspan="2" valign="top">
      <p>S3</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Blake&rdquo;</p>
      </td>
      <td colspan="2" valign="top">&nbsp;</td>
      <td colspan="2" valign="top">&nbsp;</td>
    </tr>
  </tbody>
</table>

<p>Figure 7 Example of a Supplier Table</p>

<p>As shown in Figures 4-7 relations of
different types can be
represented by a single untyped relation.&nbsp;
While this may seem like a shift away from the traditional
relational
approach it is actually just a convenient way of representing relations
of
different types in one data structure.&nbsp;
This is especially useful when relations of different
types are expected
to occur frequently when integrating data from different sources such
as those
found in the Semantic Web.&nbsp; The
traditional
approach to relations and relational algebra can still be used but it
requires
many equally typed relations to be used both as input to operations and
as
their outputs.&nbsp; The
use of untyped
relations reduces the total number of relations to be handled and with
the use
of modified relational operations allows processing to be performed
once over
these untyped relations.&nbsp; For
example, the supplier table given in Figure 7 when joined with a parts
table
would require three operations and results.&nbsp;
In an untyped system, only a single
operation is performed producing a single untyped relation.</p>

<h2>Relational SPARQL Operations</h2>

<p>Given that RDF can be represented
using a flexible, untyped
relational model what modifications to relational operations are needed
and how
do they relate to SPARQL operations?&nbsp;
A subset of SPARQL operations will be covered including:
JOIN (&ldquo;.&rdquo;),
UNION and OPTIONAL and a modified relational algebra will be given to
support
these operations.</p>

<p>The first modification required, one
suggested by Richard Cyganiak
[3], is an untyped join (SPARQL&rsquo;s JOIN).&nbsp;
An untyped join allows tuples in relations to be
successfully joined
except if a value in one relation conflicts with the value in the
other.&nbsp; If a value is unbound in
one tuple but
is bound in another then the bound value is added to the result tuple.</p>

<p>A formal definition of an untyped
JOIN (based on Date&rsquo;s
definition of Join [4]):</p>

<p style="margin-left: 36pt;">Let
r and s have attributes
X1,X2,...,Xm, Y1,Y2,...,Yn, Z1,Z2,...,Zp.&nbsp;
Where Y&rsquo;s are the common attributes,
X&rsquo;s are other attributes of r and
Z&rsquo;s are the other attributes of s.&nbsp;
The untyped JOIN of r and s is a relation t with a heading
that is the
set theoretic union of the headings r and s {X, Y, Z} and a body that
consists
of the set of all tuples {X x, Y y, Z z} such that a tuple appears in r
with X
value x or no value for X and Y value y and a tuple appears in s with Y
value y
and Z value z or no value for Z.&nbsp; Y
values for r and s may both be unbound or either maybe unbound - this
does not
lead to a successful join.&nbsp; A
successful join occurs if at least one Y value y for r and s are equal
and are
not unbound.</p>

<p>This is different to SQL and some
definitions of relational
algebra where NULL values (NULL being considered equivalent to an
unbound
value) cause join failure.&nbsp; This
behavior of joining shared attributes in r and s is shown in Figure
8.&nbsp; An example of an untyped
join of
relation r (Figure 9) and relation s (Figure 10) is shown in Figure 11.</p>

<table border="1">
  <tbody>
    <tr>
      <td valign="top">
      <p><b style="">Values of Shared Attributes</b></p>
      </td>
      <td valign="top">
      <p><b style="">Typed Join</b></p>
      </td>
      <td valign="top">
      <p><b style="">Untyped Join</b></p>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <p>r{Y = y}, s{Y = y}</p>
      </td>
      <td valign="top">
      <p>Joined</p>
      </td>
      <td valign="top">
      <p>Joined</p>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <p>r{Y = y}, s{Y = x}</p>
      </td>
      <td valign="top">
      <p>Rejected</p>
      </td>
      <td valign="top">
      <p>Rejected</p>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <p>r{Y = {}}, s{Y = y}</p>
      </td>
      <td valign="top">
      <p>Rejected</p>
      </td>
      <td valign="top">
      <p>Y = y if Joined</p>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <p>r{Y = y}, s{Y = {}}</p>
      </td>
      <td valign="top">
      <p>Rejected</p>
      </td>
      <td valign="top">
      <p style="page-break-after: avoid;">Y = y<sub>
      </sub>if Joined</p>
      </td>
    </tr>
    <tr style="height: 9.85pt;">
      <td valign="top">
      <p>r{Y = {}}, s{Y = {}}</p>
      </td>
      <td valign="top">
      <p>Rejected</p>
      </td>
      <td valign="top">
      <p style="page-break-after: avoid;">Y = {} if Joined</p>
      </td>
    </tr>
  </tbody>
</table>

<p>Figure 8 Results of a Shared Attribute (Y) of Two Relations r and s</p>
<table border="1">
  <tbody>
    <tr>
      <td valign="top">
      <p>SNO</p>
      </td>
      <td valign="top">
      <p>sno</p>
      </td>
      <td valign="top">
      <p>SNAME</p>
      </td>
      <td valign="top">
      <p>Name</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S1</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Smith&rdquo;</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S2</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Jones&rdquo;</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S3</p>
      </td>
      <td colspan="2" valign="top">
      <p style="page-break-after: avoid;">&ldquo;Blake&rdquo;</p>
      </td>
    </tr>
  </tbody>
</table>
<p>Figure 9 Relation r</p>
<table border="1">
  <tbody>
    <tr>
      <td valign="top">
      <p>SNO</p>
      </td>
      <td valign="top">
      <p>sno</p>
      </td>
      <td valign="top">
      <p>SNAME</p>
      </td>
      <td valign="top">
      <p>name</p>
      </td>
      <td valign="top">
      <p>STATUS</p>
      </td>
      <td valign="top">
      <p>integer</p>
      </td>
      <td valign="top">
      <p>CITY</p>
      </td>
      <td valign="top">
      <p>char</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S1</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Smith&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>20</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;London&rdquo;</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S2</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Jones&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>10</p>
      </td>
      <td colspan="2" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S3</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;George&rdquo;</p>
      </td>
      <td colspan="2" valign="top">&nbsp;</td>
      <td colspan="2" valign="top">&nbsp;</td>
    </tr>
  </tbody>
</table>
<p>Figure 10 Relation s</p>
<table border="1">
  <tbody>
    <tr>
      <td valign="top">
      <p>SNO</p>
      </td>
      <td valign="top">
      <p>sno</p>
      </td>
      <td valign="top">
      <p>SNAME</p>
      </td>
      <td valign="top">
      <p>name</p>
      </td>
      <td valign="top">
      <p>STATUS</p>
      </td>
      <td valign="top">
      <p>integer</p>
      </td>
      <td valign="top">
      <p>CITY</p>
      </td>
      <td valign="top">
      <p>char</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S1</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Smith&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>20</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;London&rdquo;</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S2</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Jones&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>10</p>
      </td>
      <td colspan="2" valign="top">&nbsp;</td>
    </tr>
  </tbody>
</table>

<p>Figure 11 Result of Untyped Join of r and s</p>

<p>The second untyped operation takes
the proposal by C&eacute;sar
Galindo-Legaria [6] for an outer union operator and its use in the
definition
of left outer join (which is analogous to SPARQL&rsquo;s UNION and
OPTIONAL
respectively).&nbsp; Outer
union provides
the same semantics as SPARQL&rsquo;s UNION operation while being
formally defined and
grounded in the relational model.&nbsp;
Furthermore, SPARQL&rsquo;s OPTIONAL operation can be
composed of outer union
and set difference, project, and untyped join.</p>

<p>A formal definition of OUTER UNION:</p>

<p style="margin-left: 36pt;">The
outer union of relations r
and s is the set theoretic union of the headings of r and s with a body
consisting of all tuples t such that t appears in r or s or
both.&nbsp; It does not require that r
and s have
the same attributes (types) as specified by the regular relational
union.</p>

<p>Figure 12 shows the result of performing an outer union of relations r and s from Figures 9 and 10.</p>

<table border="1">
  <tbody>
    <tr>
      <td valign="top">
      <p>SNO</p>
      </td>
      <td valign="top">
      <p>sno</p>
      </td>
      <td valign="top">
      <p>SNAME</p>
      </td>
      <td valign="top">
      <p>name</p>
      </td>
      <td valign="top">
      <p>STATUS</p>
      </td>
      <td valign="top">
      <p>integer</p>
      </td>
      <td valign="top">
      <p>CITY</p>
      </td>
      <td valign="top">
      <p>char</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S1</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Smith&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>20</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;London&rdquo;</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S2</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Jones&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>10</p>
      </td>
      <td colspan="2" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S3</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Blake&rdquo;</p>
      </td>
      <td colspan="2" valign="top">&nbsp;</td>
      <td colspan="2" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td
 colspan="2" valign="top">
      <p>S1</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Smith&rdquo;</p>
      </td>
      <td colspan="2" valign="top">&nbsp;</td>
      <td colspan="2" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S2</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Jones&rdquo;</p>
      </td>
      <td colspan="2" valign="top">&nbsp;</td>
      <td colspan="2" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S3</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;George&rdquo;</p>
      </td>
      <td colspan="2" valign="top">&nbsp;</td>
      <td colspan="2" valign="top">&nbsp;</td>
    </tr>
  </tbody>
</table>

<p>Figure 12 Result of Outer Union of r and s</p>

<p>A formal definition of LEFT OUTER JOIN:</p>

<p style="margin-left: 36pt;">The
left outer join of relations
r and s is the outer union of the join of r and s and the antijoin of r
and s.
Or formally: </p>

<p class="formula">R1 <img src="u27D5.png" alt="left outer join" height="20" width="20"/>
R2 := (R1 <img src="u22C8.png" alt="join" height="20" width="20"/> R2) <img src="u228E.png" alt="outer union" height="20" width="20"/> (R1 <img src="u22B3.png" alt="antijoin" height="20" width="20"/> R2).</p>
<p>&nbsp; Antijoin is composed of difference and semijoin.&nbsp; Semijoin is composed of join and project.&nbsp; The fully expanded version can therefore be expressed as:</p>
<p class="formula">R1 <img src="u27D5.png" alt="left outer join" height="20" width="20"/>
R2 := (R1 <img src="u22C8.png" alt="join" height="20" width="20"/> R2) <img src="u228E.png" alt="outer union" height="20" width="20"/> (R1
&minus; (&pi;(R1) (R1 <img src="u22C8.png" alt="join" height="20" width="20"/> R2)))</p>

<p>Where: "&minus;" denotes difference
and "&pi;" denotes project.&nbsp; </p>

<p></p>

<p>The use of antijoin is significant
from the point of view of
distributing the queries efficiently across multiple sites, something
that is
important in SPARQL implementations.&nbsp;
The difference and project operations are the standard
relational
versions.&nbsp; Figure 13
displays the
results of performing a left outer join with relations r and s from
Figures 9
and 10.&nbsp; Left outer
join is order dependent,
if the left outer join of s and r are performed the result the last
relation will
have the name &ldquo;George&rdquo; not
&ldquo;Blake&rdquo;.</p>

<table border="1">
  <tbody>
    <tr>
      <td valign="top">
      <p>SNO</p>
      </td>
      <td valign="top">
      <p>sno</p>
      </td>
      <td valign="top">
      <p>SNAME</p>
      </td>
      <td valign="top">
      <p>name</p>
      </td>
      <td valign="top">
      <p>STATUS</p>
      </td>
      <td valign="top">
      <p>integer</p>
      </td>
      <td valign="top">
      <p>CITY</p>
      </td>
      <td valign="top">
      <p>char</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S1</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Smith&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>20</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;London&rdquo;</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S2</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Jones&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>10</p>
      </td>
      <td colspan="2" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S3</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Blake&rdquo;</p>
      </td>
      <td colspan="2" valign="top">&nbsp;</td>
      <td colspan="2" valign="top">&nbsp;</td>
    </tr>
  </tbody>
</table>

<p>Figure 13 Result of Left Outer Join of r and s</p>

<p>Another operation defined by Galindo-Lagaria is the minimum union operator (&oplus;),
which has the same effect as performing outer union with the results of the antijoin of r and s.</p>

<p>A formal definition of MINIMUM UNION:</p>

<p style="margin-left: 36pt;">The minimum union of relations r and s is the outer union of r and s followed by removing subsumed
tuples. Tuple subsumption is defined as t<sub>1</sub> subsumes t<sub>2</sub> if t<sub>1</sub>
has more values that are bound than t<sub>2</sub> and that the values in t<sub>2</sub>
that are bound are equal to t<sub>1</sub>.&nbsp; The removal of subsumed tuples in R is denoted as R &#65516;.</p>

<p>Figure 14 shows the result of minimum union performed of relations r and s from Figures 9 and 10.</p>

<table border="1">
  <tbody>
    <tr>
      <td valign="top">
      <p>SNO</p>
      </td>
      <td valign="top">
      <p>sno</p>
      </td>
      <td valign="top">
      <p>SNAME</p>
      </td>
      <td valign="top">
      <p>name</p>
      </td>
      <td valign="top">
      <p>STATUS</p>
      </td>
      <td valign="top">
      <p>integer</p>
      </td>
      <td valign="top">
      <p>CITY</p>
      </td>
      <td valign="top">
      <p>char</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S1</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Smith&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>20</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;London&rdquo;</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S2</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Jones&rdquo;</p>
      </td>
      <td colspan="2" valign="top">
      <p>10</p>
      </td>
      <td colspan="2" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S3</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;Blake&rdquo;</p>
      </td>
      <td colspan="2" valign="top">&nbsp;</td>
      <td colspan="2" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td colspan="2" valign="top">
      <p>S3</p>
      </td>
      <td colspan="2" valign="top">
      <p>&ldquo;George&rdquo;</p>
      </td>
      <td colspan="2" valign="top">&nbsp;</td>
      <td colspan="2" valign="top">&nbsp;</td>
    </tr>

  </tbody>
</table>

<p>Figure 14 Result of Minimum Union of r and s</p>

<p>Another definition of LEFT OUTER JOIN can then be given using
minimum union:</p>

<p class="formula">R1 <img src="u27D5.png" alt="left outer join" height="20" width="20"/>
R2 := R1 <img src="u22C8.png" alt="join" height="20" width="20"/> R2
&oplus; R1</p>

<p>The result returns the same results
as given in Figure 13
and has the advantage over the previous definition in that it requires
fewer
operations.</p>

<h2>Bagging SPARQL</h2>

<p>The use of the relational model to
query RDF provides
lessons that have yet to be applied to the design of SPARQL.&nbsp;
One of the main criticisms
that can be
leveled at SPARQL is its use of multisets (bags) &ndash; SPARQL has
a DISTINCT
operator that removes duplicates.&nbsp;
RDF is set based.&nbsp; It
is
often seen as a good property of query languages to retain the same
data model,
to be consistent, this increases the easy of use and the ease of
implementation.</p>

<p>In SQL, one of the uses of duplicates
is to provide a way to
perform aggregate functions.&nbsp; That
is, being able to ask questions such as: &ldquo;What is the sum of
all salaries?&rdquo;
(using &ldquo;SELECT
SUM(salaries)&hellip;&rdquo;).&nbsp;
This query is typically performed on a table representing
employees and
their salaries within an organization&rsquo;s database.&nbsp;
Using set-based semantics
the same query
only returns the distinct salary values to be totaled, not all of
them.&nbsp; To get this query to work
using a
set-based query language a distinct entity, such as an employee, is
required in
combination with their salary in order to get the desired result.</p>

<p>The use of a set-based language
requires that the results be
paired with their relevant contextual information such as the
combination of
employee, salary and organization.&nbsp;
This contextual information becomes vital when the query
is performed on
the larger web of data.&nbsp; Asking
the
entire web for the sum of salaries is unlikely to return the results
required.&nbsp; The query
has to include
this contextual information so that salaries, for employees, employed
by a
specific organization or other group is retained.&nbsp;
These are the parts of the query that
are usually implicit locally which will need to be made explicit
globally.&nbsp; Using
consistent set-based semantics
will retain this context and allow a query to return results correctly
irrespective of what it is being queried against.</p>

<p>Another issue is one of answer
closure.&nbsp; Closure
allows the outputs of a function
to be used as the inputs to the next.&nbsp;
Currently, the results of a SPARQL SELECT query cannot be
used as input
for further querying.&nbsp; While
SPARQL
provides a CONSTRUCT query to return an RDF graph it is a new graph
(new blank
nodes are generated, for example) and is not restricted to only
returning
statements from the original.&nbsp; When
querying a web of data it is useful to be able to feed the result of
one query
into another with each query being re-executed as needed. Ideally, the
assignment of a variable to the result of a SPARQL SELECT query could
be used
within the SPARQL query language much like Date&rsquo;s relvar
[4].&nbsp; This provides a way to
build up more
powerful queries based on others and is another way to dynamically
provide
context that subsequent queries can be performed against.&nbsp; </p>

<h2>Conclusion</h2>

<p>One of the goals of the Semantic Web
is to be able to
achieve querying of disparate data sources across the web.&nbsp;
The proposed standard for
querying the
Semantic Web, SPARQL, can be seen as an extension of an existing
formalization,
the relational model. The use of the relational model provides a way to
use
previous work in query distribution, optimization and
formulation.&nbsp; The standard relational
model is not
sufficient, however, and must be extended to support untyped relations
and
operations in order to integrate these data sources.</p>

<h2>Bibliography</h2>

<p>[1] T. Berners-Lee, <i style="">Weaving
the Web</i>, Orion Publishing Group, Ltd, London, United Kingdom,
1999, pp 201.</p>

<p>[2] T. Berners-Lee, <i style="">Relational
Databases on the Semantic Web</i>, 1998; <a href="http://www.w3.org/DesignIssues/RDB-RDF.html">http://www.w3.org/DesignIssues/RDB-RDF.html</a></p>

<p>[3] R. Cyganiak, <i style=""><span style="font-family: TimesNewRomanPS-ItalicMT;">A Relational
Algebra for SPARQL</span></i>,
Digital Media Systems Laboratory, HP Laboratories Bristol, Tech. Rep,
HP
Laboratories Bristol, Tech. Rep, 2005; <a href="http://www.hpl.hp.com/techreports/2005/HPL-2005-170.html">http://www.hpl.hp.com/techreports/2005/HPL-2005-170.html</a></p>

<p>[4] C. J. Date, <i style=""><span style="font-family: TimesNewRomanPS-ItalicMT;">Database in
Depth, Relational Theory
for Practitioners</span></i>, O&rsquo;Reilly Media,
Inc, Sebastopol, California,
2005, pp. 11, 17-20, 86&ndash;93.</p>

<p>[5] C. J. Date, <i style=""><span style="font-family: TimesNewRomanPS-ItalicMT;">Relational
Database Writing 1991-1994</span></i>,
Addison Wesley Publishing Company, Inc, Reading, MA, USA, 1995, pp.
341-362.</p>

<p>[6] C. Galindo-Legarai,
&ldquo;Outerjoins as Disjunctions,&rdquo;
Proceedings of the 1994 ACM-SIGMOD Int. Conference on Management of
Data, 1994,
pp. 348 &ndash; 358.</p>

<p>[7] P. Hayes<i style="">,
RDF
Semantics</i><span style="font-family: TimesNewRomanPS-ItalicMT;">, World
Wide Web Consortium (W3C) Recommendation, 2004; <a href="http://www.w3.org/TR/rdf-mt/">http://www.w3.org/TR/rdf-mt/</a></span></p>

<p>[8] E. Prud&rsquo;hommeaux, and
A. Seaborne<i style="">, </i><i style=""><span style="font-family: TimesNewRomanPS-ItalicMT;">SPARQL Query
Language for RDF</span></i>,
World Wide Web Consortium (W3C) Candidate Recommendation, 2006; <a href="http://www.w3.org/TR/2006/CR-rdf-sparql-query-20060406/">http://www.w3.org/TR/2006/CR-rdf-sparql-query-20060406/</a></p>

</body>
</html>
