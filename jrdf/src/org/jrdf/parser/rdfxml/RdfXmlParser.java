/*  Sesame - Storage and Querying architecture for RDF and RDF Schema
 *  Copyright (C) 2001-2004 Aduna
 *  Copyright (C) 2005 Andrew Newman - Conversion to JRDF, bugs fixed,
 *    modified blank node handling.
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.jrdf.parser.rdfxml;

import org.jrdf.graph.BlankNode;
import org.jrdf.graph.GraphElementFactory;
import org.jrdf.graph.GraphElementFactoryException;
import org.jrdf.graph.GraphException;
import org.jrdf.graph.Literal;
import org.jrdf.graph.ObjectNode;
import org.jrdf.graph.PredicateNode;
import org.jrdf.graph.SubjectNode;
import org.jrdf.graph.URIReference;
import org.jrdf.parser.NamespaceListener;
import org.jrdf.parser.ParseErrorListener;
import org.jrdf.parser.ParseException;
import org.jrdf.parser.ParseLocationListener;
import org.jrdf.parser.ParserBlankNodeFactory;
import org.jrdf.parser.StatementHandler;
import org.jrdf.parser.StatementHandlerException;
import org.jrdf.parser.mem.ParserBlankNodeFactoryImpl;
import org.jrdf.vocabulary.RDF;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.XMLReader;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.TransformerConfigurationException;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.Stack;

/**
 * A parser for XML-serialized RDF. This parser operates directly
 * on the SAX events generated by a SAX-enabled XML parser. The XML parser
 * should be compliant with SAX2. You should specify which SAX parser should
 * be used by setting the <code>org.xml.sax.driver</code> property.
 * This parser is not thread-safe, therefore it's public methods are
 * synchronized.
 * <p/>
 * To parse a document using this parser:
 * <ul>
 * <li>Create an instance of RdfXmlParser, optionally supplying it with your
 * own ValueFactory.</li>
 * <li>Set the StatementHandler.</li>
 * <li>Optionally, set the ParseErrorListener, ParseLocationListener and/or
 * NamespaceListener.</li>
 * <li>Optionally, specify whether the parser should verify the data it
 * parses and whether it should stop immediately when it finds an error in
 * the data (both default to <tt>true</tt>).
 * <li>Call the parse method.</li>
 * </ul>
 * Example code:
 * <pre>
 * Graph jrdfGraph = new GraphImpl();
 * Parser parser = new RdfXmlParser(jrdfGraph);
 * parser.setStatementHandler(myStatementHandler);
 * parser.setParseErrorListener(myParseErrorListener);
 * parser.setVerifyData(true);
 * parser.stopAtFirstError(false);
 * <p/>
 * // Parse the data from inputStream, resolving any
 * // relative URIs against http://foo/bar:
 * parser.parse(inputStream, "http://foo/bar");
 * </pre>
 */
public class RdfXmlParser implements org.jrdf.parser.Parser {

    /**
     * The rdf:type resource. *
     */
    private URIReference RDF_TYPE;

    /**
     * The rdf:subject resource. *
     */
    private URIReference RDF_SUBJECT;

    /**
     * The rdf:predicate resource. *
     */
    private URIReference RDF_PREDICATE;

    /**
     * The rdf:object resource. *
     */
    private URIReference RDF_OBJECT;

    /**
     * The rdf:Statement resource. *
     */
    private URIReference RDF_STATEMENT;

    /**
     * The rdf:li resource. *
     */
    private URIReference RDF_LI;

    /**
     * The rdf:first resource. *
     */
    private URIReference RDF_FIRST;

    /**
     * The rdf:rest resource. *
     */
    private URIReference RDF_REST;

    /**
     * The rdf:nil resource. *
     */
    private URIReference RDF_NIL;

    /**
     * A filter filtering calls to SAX methods specifically for this parser.
     */
    private SAXFilter _saxFilter;

    /**
     * A factory for creating resources, bNodes and literals.
     */
    private GraphElementFactory _valueFactory;

    private ParserBlankNodeFactory _bNodeFactory;

    /**
     * The object to report statements to.
     */
    private StatementHandler _statementHandler;

    /**
     * The object to report parse errors to.
     */
    private ParseErrorListener _errorListener;

    /**
     * The base URIReference for resolving relative URIs. This variable is set/modified
     * by the SAXFilter during parsing such that it always represents the URI
     * of the context in which elements are reported.
     */
    private URI _baseURI;

    /**
     * The base URI of the document. This variable is set when
     * <tt>parse(inputStream, baseURI)</tt> is called and will not be changed
     * during parsing.
     */
    private String _documentURI;

    /**
     * The language of literal values as can be specified using xml:lang
     * attributes. This variable is set/modified by the SAXFilter during
     * parsing such that it always represents the language of the context
     * in which elements are reported.
     */
    private String _xmlLang;

    /**
     * A stack of node- and property elements.
     */
    private Stack _elementStack = new Stack();

    /**
     * A set containing URIs that have been generated as a result of rdf:ID
     * attributes. These URIs should be unique within a single document.
     */
    private Set _usedIDs = new HashSet();

    /**
     * Flag indicating whether the parser should check the data it parses.
     */
    boolean _verifyData = true;

    /**
     * Flag indicating whether the parser should preserve bnode identifiers specified
     * in the source.
     */
    boolean _preserveBNodeIds;

    /**
     * Indicates how datatyped literals should be handled. Legal
     * values are <tt>DT_IGNORE</tt>, <tt>DT_VERIFY</tt> and
     * <tt>DT_NORMALIZE</tt>.
     */
    private int _datatypeHandling;

    /**
     * Flag indicating whether the parser should stop parsing when it finds
     * an error in the data.
     */
    boolean _stopAtFirstError = true;

    /**
     * Creates a new RdfXmlParser that will use the supplied GraphElementFactory
     * to create objects for resources, bNodes and literals.
     *
     * @param graphElementFactory A GraphElementFactory.
     */
    public RdfXmlParser(GraphElementFactory graphElementFactory) throws GraphException {
        this(
                graphElementFactory,
                new ParserBlankNodeFactoryImpl(graphElementFactory)
        );
    }

    /**
     * Creates a new RdfXmlParser that will use the supplied GraphElementFactory
     * to create objects for resources, bNodes and literals.
     *
     * @param valueFactory           A GraphElementFactory.
     * @param parserBlankNodeFactory A ParserBlankNodeFactory.
     */
    public RdfXmlParser(
            GraphElementFactory valueFactory,
            ParserBlankNodeFactory parserBlankNodeFactory
    ) throws GraphException {
        try {
            init(valueFactory, parserBlankNodeFactory);

            // Initialize the statement handler to empty.
            setStatementHandler(new StatementHandler() {
                public void handleStatement(SubjectNode subject, PredicateNode predicate,
                        ObjectNode object) {
                }
            });
        }
        catch (TransformerConfigurationException tce) {
            throw new GraphException(tce);
        }
    }

    private void init(
            GraphElementFactory valueFactory,
            ParserBlankNodeFactory parserBlankNodeFactory
    )
            throws TransformerConfigurationException, GraphException {
        _valueFactory = valueFactory;
        _bNodeFactory = parserBlankNodeFactory;

        _datatypeHandling = DT_VERIFY;

        try {
            RDF_TYPE = _valueFactory.createResource(RDF.TYPE);
            RDF_SUBJECT = _valueFactory.createResource(RDF.SUBJECT);
            RDF_PREDICATE = _valueFactory.createResource(RDF.PREDICATE);
            RDF_OBJECT = _valueFactory.createResource(RDF.OBJECT);
            RDF_STATEMENT = _valueFactory.createResource(RDF.STATEMENT);
            RDF_LI = _valueFactory.createResource(RDF.li);
            RDF_FIRST = _valueFactory.createResource(RDF.FIRST);
            RDF_REST = _valueFactory.createResource(RDF.REST);
            RDF_NIL = _valueFactory.createResource(RDF.NIL);
        }
        catch (GraphElementFactoryException ex) {
            throw new GraphException(ex);
        }

        // SAXFilter does some filtering and verifying of SAX events
        _saxFilter = new SAXFilter(this);
    }

    // implements Parser.setStatementHandler(StatementHandler)
    public synchronized void setStatementHandler(StatementHandler sh) {
        _statementHandler = sh;
    }

    // implements Parser.setParseErrorListener(ParseErrorListener)
    public synchronized void setParseErrorListener(ParseErrorListener el) {
        _errorListener = el;
    }

    // implements Parser.setParseLocationListener(ParseLocationListener)
    public synchronized void setParseLocationListener(ParseLocationListener ll) {
        _saxFilter.setParseLocationListener(ll);
    }

    // implements Parser.setNamespaceListener(NamespaceListener)
    public synchronized void setNamespaceListener(NamespaceListener nl) {
        _saxFilter.setNamespaceListener(nl);
    }

    // implements Parser.setVerifyData(boolean)
    public synchronized void setVerifyData(boolean verifyData) {
        _verifyData = verifyData;
    }

    // implements Parser.setPreserveBNodeIds(boolean)
    public synchronized void setPreserveBNodeIds(boolean preserveBNodeIds) {
        _preserveBNodeIds = preserveBNodeIds;
    }

    // implements Parser.setStopAtFirstError(boolean)
    public synchronized void setStopAtFirstError(boolean stopAtFirstError) {
        _stopAtFirstError = stopAtFirstError;
    }

    // implements Parser.setDatatypeHandling(int)
    public void setDatatypeHandling(int datatypeHandling) {
        _datatypeHandling = datatypeHandling;
    }

    /**
     * Sets the parser in a mode to parse stand-alone RDF documents. In
     * stand-alone RDF documents, the enclosing <tt>rdf:RDF</tt> root element is
     * optional if this root element contains just one element (e.g.
     * <tt>rdf:Description</tt>.
     */
    public void setParseStandAloneDocuments(boolean standAloneDocs) {
        _saxFilter.setParseStandAloneDocuments(standAloneDocs);
    }

    /**
     * Returns whether the parser is currently in a mode to parse stand-alone
     * RDF documents.
     *
     * @see #setParseStandAloneDocuments
     */
    public boolean getParseStandAloneDocuments() {
        return _saxFilter.getParseStandAloneDocuments();
    }

    /**
     * Parses the data from the supplied InputStream, using the supplied
     * baseURI to resolve any relative URI references.
     *
     * @param in      The InputStream from which to read the data.
     * @param baseURI The URI associated with the data in the InputStream.
     * @throws IOException               If an I/O error occurred while data was read
     *                                   from the InputStream.
     * @throws ParseException            If the parser has found an unrecoverable
     *                                   parse error.
     * @throws StatementHandlerException If the configured statement handler
     *                                   encountered an unrecoverable error.
     * @throws IllegalArgumentException  If the supplied input stream or
     *                                   base URI is <tt>null</tt>.
     */
    public synchronized void parse(InputStream in, String baseURI) throws
            IOException, ParseException, StatementHandlerException {
        if (null == in) {
            throw new IllegalArgumentException("Input stream cannot be 'null'");
        }
        if (null == baseURI) {
            throw new IllegalArgumentException("Base URI cannot be 'null'");
        }

        InputSource inputSource = new InputSource(in);
        inputSource.setSystemId(baseURI);

        _parse(inputSource);
    }

    /**
     * Parses the data from the supplied Reader, using the supplied baseURI
     * to resolve any relative URI references.
     *
     * @param reader  The Reader from which to read the data.
     * @param baseURI The URI associated with the data in the InputStream.
     * @throws IOException               If an I/O error occurred while data was read
     *                                   from the InputStream.
     * @throws ParseException            If the parser has found an unrecoverable
     *                                   parse error.
     * @throws StatementHandlerException If the configured statement handler
     *                                   has encountered an unrecoverable error.
     * @throws IllegalArgumentException  If the supplied reader or base URI
     *                                   is <tt>null</tt>.
     */
    public synchronized void parse(Reader reader, String baseURI) throws
            IOException, ParseException, StatementHandlerException {
        if (null == reader) {
            throw new IllegalArgumentException("Reader cannot be 'null'");
        }
        if (null == baseURI) {
            throw new IllegalArgumentException("Base URI cannot be 'null'");
        }

        InputSource inputSource = new InputSource(reader);
        inputSource.setSystemId(baseURI);

        _parse(inputSource);
    }

    private void _parse(InputSource inputSource) throws IOException,
            ParseException, StatementHandlerException {
        try {
            _documentURI = inputSource.getSystemId();

            //_saxFilter.clear();
            _saxFilter.setDocumentURI(_documentURI);

            SAXParserFactory factory = SAXParserFactory.newInstance();
            factory.setFeature("http://xml.org/sax/features/namespaces", true);
            factory.setFeature("http://xml.org/sax/features/namespace-prefixes", false);
            XMLReader xmlReader = factory.newSAXParser().getXMLReader();
            xmlReader.setContentHandler(_saxFilter);
            xmlReader.parse(inputSource);
        }
        catch (ParserConfigurationException pce) {
            throw new ParseException(pce, -1, -1);
        }
        catch (SAXParseException e) {
            Exception wrappedExc = e.getException();
            if (null == wrappedExc) {
                wrappedExc = e;
            }
            throw new ParseException(wrappedExc, e.getLineNumber(), e.getColumnNumber());
        }
        catch (SAXException e) {
            Exception wrappedExc = e.getException();
            if (null == wrappedExc) {
                wrappedExc = e;
            }
            if (wrappedExc instanceof StatementHandlerException) {
                throw (StatementHandlerException) wrappedExc;
            } else {
                throw new ParseException(wrappedExc, -1, -1);
            }
        }
        finally {
            // Clean up
            _saxFilter.clear();
            _baseURI = null;
            _xmlLang = null;
            _elementStack.clear();
            _usedIDs.clear();
            _bNodeFactory.clear();
        }
    }

    void setBaseURI(URI baseURI) {
        _baseURI = baseURI;
    }

    void setXmlLang(String xmlLang) {
        if ("".equals(xmlLang)) {
            _xmlLang = null;
        } else {
            _xmlLang = xmlLang;
        }
    }

    void startElement(String namespaceURI, String localName, String qName,
            Atts atts) throws SAXException {
        if (_topIsProperty()) {

            // this element represents the subject and/or object of a statement
            _processNodeElt(namespaceURI, localName, qName, atts, false);
        } else {

            // this element represents a property
            _processPropertyElt(namespaceURI, localName, qName, atts, false);
        }
    }

    void endElement(String namespaceURI, String localName,
            String qName) throws SAXException {
        Object topElement = _peekStack(0);

        if (topElement instanceof NodeElement) {
            // Check if top node is 'volatile', meaning that it doesn't have a
            // start- and end element associated with it.
            if (((NodeElement) topElement).isVolatile()) {
                _elementStack.pop();
            }
        } else {
            // topElement instanceof PropertyElement
            PropertyElement predicate = (PropertyElement) topElement;

            if (predicate.parseCollection()) {
                SubjectNode lastListResource = predicate.getLastListResource();

                if (null == lastListResource) {
                    // no last list resource, list must have been empty.
                    NodeElement subject = (NodeElement) _peekStack(1);

                    _reportStatement(subject.getResource(), predicate.getURI(), RDF_NIL);

                    _handleReification(RDF_NIL);
                } else {
                    // Generate the final tail of the list.
                    _reportStatement(lastListResource, RDF_REST, RDF_NIL);
                }
            }

        }

        _elementStack.pop();
    }

    void emptyElement(String namespaceURI, String localName, String qName,
            Atts atts) throws SAXException {
        if (_topIsProperty()) {
            // this element represents the subject and/or object of a statement
            _processNodeElt(namespaceURI, localName, qName, atts, true);
        } else {
            // this element represents a property
            _processPropertyElt(namespaceURI, localName, qName, atts, true);
        }
    }

    void text(String text) throws SAXException {
        if (!_topIsProperty()) {
            throw new SAXException("unexpected literal");
        }

        PropertyElement propEl = (PropertyElement) _peekStack(0);
        String datatype = propEl.getDatatype();
        Literal lit = _createLiteral(text, _xmlLang, datatype);

        NodeElement subject = (NodeElement) _peekStack(1);
        PropertyElement predicate = (PropertyElement) _peekStack(0);

        _reportStatement(subject.getResource(), predicate.getURI(), lit);

        _handleReification(lit);
    }

    /* Process a node element (can be both subject and object) */
    private void _processNodeElt(
            String namespaceURI, String localName, String qName, Atts atts,
            boolean isEmptyElt) throws SAXException {
        if (_verifyData) {
            // Check the element name
            _checkNodeEltName(namespaceURI, localName, qName);
        }

        SubjectNode nodeResource = _getNodeResource(atts);
        NodeElement nodeElement = new NodeElement(nodeResource);

        if (!_elementStack.isEmpty()) {
            // node can be object of a statement, or part of an rdf:List
            NodeElement subject = (NodeElement) _peekStack(1);
            PropertyElement predicate = (PropertyElement) _peekStack(0);

            if (predicate.parseCollection()) {
                SubjectNode lastListRes = predicate.getLastListResource();
                BlankNode newListRes = _createBNode();

                if (null == lastListRes) {
                    // first element in the list
                    _reportStatement(subject.getResource(),
                            predicate.getURI(), newListRes);

                    _handleReification(newListRes);
                } else {
                    // not the first element in the list
                    _reportStatement(lastListRes, RDF_REST, newListRes);
                }

                _reportStatement((SubjectNode) newListRes, (PredicateNode) RDF_FIRST,
                        (ObjectNode) nodeResource);
                predicate.setLastListResource(newListRes);
            } else {
                _reportStatement(subject.getResource(),
                        (PredicateNode) predicate.getURI(), (ObjectNode) nodeResource);

                _handleReification((ObjectNode) nodeResource);
            }
        }

        if (!"Description".equals(localName) ||
                !namespaceURI.equals(RDF.baseURI.toString())) {
            // element name is uri's type
            URIReference className = null;
            if ("".equals(namespaceURI)) {
                // No namespace, use base URI
                className = _buildResourceFromLocalName(localName);
            } else {
                className = _createURI(namespaceURI + localName);
            }
            _reportStatement(nodeResource, RDF_TYPE, className);
        }

        Att type = atts.removeAtt(RDF.baseURI.toString(), "type");
        if (null != type) {
            // rdf:type attribute, value is a URI-reference
            URIReference className = _buildURIFromReference(type.getValue());

            _reportStatement(nodeResource, RDF_TYPE, className);
        }

        if (_verifyData) {
            _checkRdfAtts(atts);
        }

        _processSubjectAtts(nodeElement, atts);

        if (!isEmptyElt) {
            _elementStack.push(nodeElement);
        }
    }

    /**
     * Retrieves the resource of a node element (subject or object) using
     * relevant attributes (rdf:ID, rdf:about and rdf:nodeID) from its
     * attributes list.
     *
     * @return a resource or a bNode.
     */
    private SubjectNode _getNodeResource(Atts atts) throws SAXException {
        Att id = atts.removeAtt(RDF.baseURI.toString(), "ID");
        Att about = atts.removeAtt(RDF.baseURI.toString(), "about");
        Att nodeID = atts.removeAtt(RDF.baseURI.toString(), "nodeID");

        if (_verifyData) {
            int definedAttsCount = 0;

            if (null != id) {
                definedAttsCount++;
            }
            if (null != about) {
                definedAttsCount++;
            }
            if (null != nodeID) {
                definedAttsCount++;
            }

            if (1 < definedAttsCount) {
                sendError(
                        "Only one of the attributes rdf:ID, rdf:about or rdf:nodeID can be used here");
            }
        }

        SubjectNode result = null;

        if (null != id) {
            result = _buildURIFromID(id.getValue());
        } else if (null != about) {
            result = _buildURIFromReference(about.getValue());
        } else if (null != nodeID) {
            result = _createBNode(nodeID.getValue());
        } else {
            // No resource specified, generate a bNode
            result = _createBNode();
        }

        return result;
    }

    /**
     * processes subject attributes. *
     */
    private void _processSubjectAtts(NodeElement nodeElt, Atts atts)
            throws SAXException {

        SubjectNode subject = nodeElt.getResource();

        Iterator iter = atts.iterator();

        while (iter.hasNext()) {
            Att att = (Att) iter.next();
            URIReference predicate = _createURI(att.getURI());
            Literal lit = _createLiteral(att.getValue(), _xmlLang, null);

            _reportStatement(subject, predicate, lit);
        }
    }

    private void _processPropertyElt(
            String namespaceURI, String localName, String qName, Atts atts,
            boolean isEmptyElt) throws SAXException {
        if (_verifyData) {
            _checkPropertyEltName(namespaceURI, localName, qName);
        }

        // Get the URI of the property
        URIReference propURI = null;
        if ("".equals(namespaceURI)) {
            // no namespace URI
            sendError("unqualified property element <" + qName + "> not allowed");
            // Use base URI as namespace:
            propURI = _buildResourceFromLocalName(localName);
        } else {
            propURI = _createURI(namespaceURI + localName);
        }

        // List expansion rule
        if (propURI.equals(RDF_LI)) {
            NodeElement subject = (NodeElement) _peekStack(0);
            propURI = _createURI(
                    RDF.baseURI.toString() + "_" + subject.getNextLiCounter());
        }

        // Push the property on the stack.
        PropertyElement predicate = new PropertyElement(propURI);
        _elementStack.push(predicate);

        // Check if property has a reification ID
        Att id = atts.removeAtt(RDF.baseURI.toString(), "ID");
        if (null != id) {
            URIReference reifURI = _buildURIFromID(id.getValue());
            predicate.setReificationURI(reifURI);
        }

        // Check for presence of rdf:parseType attribute
        Att parseType = atts.removeAtt(RDF.baseURI.toString(), "parseType");

        if (null != parseType) {
            if (_verifyData) {
                _checkNoMoreAtts(atts);
            }

            String parseTypeValue = parseType.getValue();

            if ("Resource".equals(parseTypeValue)) {
                BlankNode objectResource = _createBNode();
                NodeElement subject = (NodeElement) _peekStack(1);

                _reportStatement(
                        subject.getResource(), propURI, objectResource);

                if (isEmptyElt) {
                    _handleReification(objectResource);
                } else {
                    NodeElement object = new NodeElement(objectResource);
                    object.setIsVolatile(true);
                    _elementStack.push(object);
                }
            } else if ("Collection".equals(parseTypeValue)) {
                if (isEmptyElt) {
                    NodeElement subject = (NodeElement) _peekStack(1);
                    _reportStatement(subject.getResource(), propURI, RDF_NIL);
                    _handleReification(RDF_NIL);
                } else {
                    predicate.setParseCollection(true);
                }
            } else {
                // other parseType
                if (!"Literal".equals(parseTypeValue)) {
                    sendWarning("unknown parseType: " + parseType.getValue());
                }

                if (isEmptyElt) {
                    NodeElement subject = (NodeElement) _peekStack(1);

                    Literal lit = _createLiteral("", null, RDF.XML_LITERAL.toString());

                    _reportStatement(subject.getResource(), propURI, lit);

                    _handleReification(lit);
                } else {
                    // The next string is an rdf:XMLLiteral
                    predicate.setDatatype(RDF.XML_LITERAL.toString());

                    _saxFilter.setParseLiteralMode();
                }
            }
        }
        // parseType == null
        else if (isEmptyElt) {
            // empty element without an rdf:parseType attribute

            if (0 == atts.size()) {
                // element had no attributes, or only the optional rdf:ID
                NodeElement subject = (NodeElement) _peekStack(1);
                Literal lit = _createLiteral("", _xmlLang, null);
                _reportStatement(subject.getResource(), propURI, lit);
                _handleReification(lit);
            } else {
                // Create resource for the statement's object.
                SubjectNode resourceRes = _getPropertyResource(atts);

                // All special rdf attributes have been checked/removed.
                if (_verifyData) {
                    _checkRdfAtts(atts);
                }

                NodeElement resourceElt = new NodeElement(resourceRes);
                NodeElement subject = (NodeElement) _peekStack(1);

                _reportStatement((SubjectNode) subject.getResource(),
                        (PredicateNode) propURI, (ObjectNode) resourceRes);
                _handleReification((ObjectNode) resourceRes);

                Att type = atts.removeAtt(RDF.baseURI.toString(), "type");
                if (null != type) {
                    // rdf:type attribute, value is a URI-reference
                    URIReference className = _buildURIFromReference(type.getValue());

                    _reportStatement(resourceRes, RDF_TYPE, className);
                }

                _processSubjectAtts(resourceElt, atts);
            }

            // Empty element has been pushed on the stack already, remove it.
            _elementStack.pop();
        } else {
            // Not an empty element, sub elements will follow.

            // Check for rdf:datatype attribute
            Att datatype = atts.removeAtt(RDF.baseURI.toString(), "datatype");
            if (null != datatype) {
                predicate.setDatatype(datatype.getValue());
            }

            // No more attributes are expected.
            if (_verifyData) {
                _checkNoMoreAtts(atts);
            }
        }
    }

    /**
     * Retrieves the object resource of a property element using relevant attributes
     * (rdf:resource and rdf:nodeID) from its attributes list.
     *
     * @return a resource or a bNode.
     */
    private SubjectNode _getPropertyResource(Atts atts) throws SAXException {
        Att resource = atts.removeAtt(RDF.baseURI.toString(), "resource");
        Att nodeID = atts.removeAtt(RDF.baseURI.toString(), "nodeID");

        if (_verifyData) {
            int definedAttsCount = 0;

            if (null != resource) {
                definedAttsCount++;
            }
            if (null != nodeID) {
                definedAttsCount++;
            }

            if (1 < definedAttsCount) {
                sendError(
                        "Only one of the attributes rdf:resource or rdf:nodeID can be used here");
            }
        }

        SubjectNode result = null;

        if (null != resource) {
            result = _buildURIFromReference(resource.getValue());
        } else if (null != nodeID) {
            result = _createBNode(nodeID.getValue());
        } else {
            // No resource specified, generate a bNode
            result = _createBNode();
        }

        return result;
    }

    /*
    * Processes any rdf:ID attributes that generate reified statements. This
    * method assumes that a PropertyElement (which can have an rdf:ID
    * attribute) is on top of the stack, and a NodeElement is below that.
    */
    private void _handleReification(ObjectNode value) throws SAXException {
        PropertyElement predicate = (PropertyElement) _peekStack(0);

        if (predicate.isReified()) {
            NodeElement subject = (NodeElement) _peekStack(1);
            URIReference reifRes = predicate.getReificationURI();
            _reifyStatement((SubjectNode) reifRes, subject.getResource(), predicate.getURI(), value);
        }
    }

    private void _reifyStatement(SubjectNode reifNode, SubjectNode subj,
            PredicateNode pred, ObjectNode obj) throws SAXException {
        _reportStatement(reifNode, RDF_TYPE, RDF_STATEMENT);
        _reportStatement(reifNode, (PredicateNode) RDF_SUBJECT, (ObjectNode) subj);
        _reportStatement(reifNode, (PredicateNode) RDF_PREDICATE, (ObjectNode) pred);
        _reportStatement(reifNode, RDF_OBJECT, obj);
    }

    /**
     * Builds a Resource from a non-qualified localname.
     */
    private URIReference _buildResourceFromLocalName(String localName) throws
            SAXException {
        // Resolve the relative URI against the base URI
        String uriString = _baseURI.resolve("#" + localName).toString();
        return _createURI(uriString);
    }

    /**
     * Builds a Resource from the value of an rdf:ID attribute.
     */
    private URIReference _buildURIFromID(String id) throws SAXException {
        if (_verifyData) {
            // Check if 'id' is a legal NCName
            if (!XmlUtil.isNCName(id)) {
                sendError("Not an XML Name: " + id);
            }
        }

        // Resolve the relative URI against the base URI
        String uriString = _baseURI.resolve("#" + id).toString();

        if (_verifyData) {
            // uriString should be unique in the current document

            if (!_usedIDs.add(uriString)) {
                // uriString was not added because the set already contained
                // an equal string.
                sendError("'" + id + "' already used as ID value, values of rdf:ID attributes should be unique");
            }
        }

        return _createURI(uriString);
    }

    private URIReference _buildURIFromReference(String uriReference) throws SAXException {
        try {
            URI relUri = new URI(uriReference);

            if (_verifyData) {
                if (null == relUri.getScheme() && // Relative URI that is not a self-reference
                        !(null == relUri.getScheme() &&
                                null == relUri.getAuthority() &&
                                null == relUri.getQuery() &&
                                0 == relUri.getPath().length()) &&
                        _baseURI.isOpaque()) {
                    sendError("Relative URI '" + uriReference + "' cannot be resolved using the opaque base URI '" +
                            _baseURI + "'");
                }
            }
            if ("".equals(uriReference)) {
                return _createURI(_baseURI);
            }
            return _createURI(_baseURI.resolve(relUri));
        }
        catch (URISyntaxException ex) {
            throw new SAXException(ex);
        }
    }

    private URIReference _createURI(URI uri) throws SAXException {
        try {
            return _valueFactory.createResource(uri);
        }
        catch (Exception e) {
            throw new SAXException(e);
        }
    }

    private URIReference _createURI(String uri) throws SAXException {
        try {
            return _valueFactory.createResource(URI.create(uri));
        }
        catch (Exception e) {
            throw new SAXException(e);
        }
    }

    private BlankNode _createBNode() throws SAXException {
        try {
            return _bNodeFactory.createBlankNode();
        }
        catch (Exception e) {
            throw new SAXException(e);
        }
    }

    private BlankNode _createBNode(String nodeID) throws SAXException {
        if (_verifyData) {
            // Check if 'nodeID' is a legal NCName
            if (!XmlUtil.isNCName(nodeID)) {
                sendError("Not an XML Name: " + nodeID);
            }
        }

        try {
            return _bNodeFactory.createBlankNode(nodeID);
        }
        catch (Exception e) {
            throw new SAXException(e);
        }
    }

    private Literal _createLiteral(String label, String lang, String datatype)
            throws SAXException {
        try {
            if (null != datatype) {
                if (DT_VERIFY == _datatypeHandling) {
                    if (!XmlDatatypeUtil.isValidValue(label, datatype)) {
                        throw new Exception("'" + label +
                                "' is not a valid value for datatype " +
                                datatype);
                    }
                } else if (DT_NORMALIZE == _datatypeHandling) {
                    label = XmlDatatypeUtil.normalize(label, datatype);
                }

                return _valueFactory.createLiteral(label, new URI(datatype));
            } else if (null != lang) {
                return _valueFactory.createLiteral(label, lang);
            } else {
                return _valueFactory.createLiteral(label);
            }
        }
        catch (Exception e) {
            throw new SAXException(e);
        }
    }

    private Object _peekStack(int distFromTop) {
        return _elementStack.get(_elementStack.size() - 1 - distFromTop);
    }

    private boolean _topIsProperty() {
        return
                _elementStack.isEmpty() ||
                        _peekStack(0) instanceof PropertyElement;
    }

    /**
     * Checks whether the node element name is from the RDF namespace and, if so, if it is
     * allowed to be used in a node element. If the name is equal to one of the disallowed
     * names (RDF, ID, about, parseType, resource, nodeID, datatype and li), an error is
     * generated. If the name is not defined in the RDF namespace, but it claims that it
     * is from this namespace, a warning is generated.
     */
    private void _checkNodeEltName(String namespaceURI, String localName,
            String qName) throws SAXException {
        if (RDF.baseURI.toString().equals(namespaceURI)) {

            if ("Description".equals(localName) ||
                    "Seq".equals(localName) ||
                    "Bag".equals(localName) ||
                    "Alt".equals(localName) ||
                    "Statement".equals(localName) ||
                    "Property".equals(localName) ||
                    "List".equals(localName) ||
                    "subject".equals(localName) ||
                    "predicate".equals(localName) ||
                    "object".equals(localName) ||
                    "type".equals(localName) ||
                    "value".equals(localName) ||
                    "first".equals(localName) ||
                    "rest".equals(localName) ||
                    "nil".equals(localName) ||
                    localName.startsWith("_")) {
                // These are OK
            } else if (
                    "li".equals(localName) ||
                            "RDF".equals(localName) ||
                            "ID".equals(localName) ||
                            "about".equals(localName) ||
                            "parseType".equals(localName) ||
                            "resource".equals(localName) ||
                            "nodeID".equals(localName) ||
                            "datatype".equals(localName)) {
                sendError("<" + qName + "> not allowed as node element");
            } else if (
                    "bagID".equals(localName) ||
                            "aboutEach".equals(localName) ||
                            "aboutEachPrefix".equals(localName)) {
                sendError(qName + " is no longer a valid RDF name");
            } else {
                sendWarning("unknown rdf element <" + qName + ">");
            }
        }
    }

    /**
     * Checks whether the property element name is from the RDF namespace and, if so,
     * if it is allowed to be used in a property element. If the name is equal to one of
     * the disallowed names (RDF, ID, about, parseType, resource and li), an error is
     * generated. If the name is not defined in the RDF namespace, but it claims that it
     * is from this namespace, a warning is generated.
     */
    private void _checkPropertyEltName(String namespaceURI, String localName,
            String qName) throws SAXException {
        if (RDF.baseURI.toString().equals(namespaceURI)) {

            if ("li".equals(localName) ||
                    "Seq".equals(localName) ||
                    "Bag".equals(localName) ||
                    "Alt".equals(localName) ||
                    "Statement".equals(localName) ||
                    "Property".equals(localName) ||
                    "List".equals(localName) ||
                    "subject".equals(localName) ||
                    "predicate".equals(localName) ||
                    "object".equals(localName) ||
                    "type".equals(localName) ||
                    "value".equals(localName) ||
                    "first".equals(localName) ||
                    "rest".equals(localName) ||
                    "nil".equals(localName) ||
                    localName.startsWith("_")) {
                // These are OK
            } else if (
                    "Description".equals(localName) ||
                            "RDF".equals(localName) ||
                            "ID".equals(localName) ||
                            "about".equals(localName) ||
                            "parseType".equals(localName) ||
                            "resource".equals(localName) ||
                            "nodeID".equals(localName) ||
                            "datatype".equals(localName)) {
                sendError("<" + qName + "> not allowed as property element");
            } else if (
                    "bagID".equals(localName) ||
                            "aboutEach".equals(localName) ||
                            "aboutEachPrefix".equals(localName)) {
                sendError(qName + " is no longer a valid RDF name");
            } else {
                sendWarning("unknown rdf element <" + qName + ">");
            }
        }
    }

    /**
     * Checks whether 'atts' contains attributes from the RDF namespace that are not
     * allowed as attributes. If such an attribute is found, an error is generated and
     * the attribute is removed from 'atts'. If the attribute is not defined in the RDF
     * namespace, but it claims that it is from this namespace, a warning is generated.
     */
    private void _checkRdfAtts(Atts atts) throws SAXException {
        Iterator iter = atts.iterator();

        while (iter.hasNext()) {
            Att att = (Att) iter.next();

            if (RDF.baseURI.toString().equals(att.getNamespace())) {
                String localName = att.getLocalName();

                if ("Seq".equals(localName) ||
                        "Bag".equals(localName) ||
                        "Alt".equals(localName) ||
                        "Statement".equals(localName) ||
                        "Property".equals(localName) ||
                        "List".equals(localName) ||
                        "subject".equals(localName) ||
                        "predicate".equals(localName) ||
                        "object".equals(localName) ||
                        "type".equals(localName) ||
                        "value".equals(localName) ||
                        "first".equals(localName) ||
                        "rest".equals(localName) ||
                        "nil".equals(localName) ||
                        localName.startsWith("_")) {
                    // These are OK
                } else if (
                        "Description".equals(localName) ||
                                "li".equals(localName) ||
                                "RDF".equals(localName) ||
                                "ID".equals(localName) ||
                                "about".equals(localName) ||
                                "parseType".equals(localName) ||
                                "resource".equals(localName) ||
                                "nodeID".equals(localName) ||
                                "datatype".equals(localName)) {
                    sendError("'" + att.getQName() + "' not allowed as attribute name");
                    iter.remove();
                } else if (
                        "bagID".equals(localName) ||
                                "aboutEach".equals(localName) ||
                                "aboutEachPrefix".equals(localName)) {
                    sendError(att.getQName() + " is no longer a valid RDF name");
                } else {
                    sendWarning("unknown rdf attribute '" + att.getQName() + "'");
                }
            }
        }
    }

    /**
     * Checks whether 'atts' is empty. If this is not the case, a warning is generated
     * for each attribute that is still present.
     */
    private void _checkNoMoreAtts(Atts atts) throws SAXException {
        if (0 < atts.size()) {
            Iterator iter = atts.iterator();

            while (iter.hasNext()) {
                Att att = (Att) iter.next();
                iter.remove();
            }
        }
    }

    /**
     * Reports a stament to the configured StatementHandler.
     *
     * @param subject   The statement's subject.
     * @param predicate The statement's predicate.
     * @param object    The statement's object.
     * @throws SAXException If the configured StatementHandler throws a
     *                      StatementHandlerException, which will be wrapped in a SAXException.
     */
    private void _reportStatement(SubjectNode subject, PredicateNode predicate,
            ObjectNode object) throws SAXException {
        try {
            _statementHandler.handleStatement(subject, predicate, object);
        }
        catch (StatementHandlerException e) {
            // Wrap exception in a SAXException, it will be unwrapped in the
            // parse() method
            throw new SAXException(e);
        }
    }

    void sendWarning(String msg) {
        if (null != _errorListener) {
            Locator loc = _saxFilter.getLocator();
            if (null == loc) {
                _errorListener.warning(msg, -1, -1);
            } else {
                _errorListener.warning(msg, loc.getLineNumber(), loc.getColumnNumber());
            }
        }
    }

    void sendError(String msg) throws SAXException {
        if (null != _errorListener) {
            Locator loc = _saxFilter.getLocator();
            if (null == loc) {
                _errorListener.error(msg, -1, -1);
            } else {
                _errorListener.error(msg, loc.getLineNumber(), loc.getColumnNumber());
            }
        }

        if (_stopAtFirstError) {
            throw new SAXException(msg);
        }
    }

    void sendFatalError(String msg) throws SAXException {
        if (null != _errorListener) {
            Locator loc = _saxFilter.getLocator();
            if (null == loc) {
                _errorListener.fatalError(msg, -1, -1);
            } else {
                _errorListener.fatalError(msg, loc.getLineNumber(), loc.getColumnNumber());
            }
        }

        throw new SAXException(msg);
    }

    static class NodeElement {
        private SubjectNode _resource;
        private boolean _isVolatile;
        private int _liCounter = 1;

        NodeElement(SubjectNode resource) {
            _resource = resource;
        }

        public SubjectNode getResource() {
            return _resource;
        }

        public void setIsVolatile(boolean isVolatile) {
            _isVolatile = isVolatile;
        }

        public boolean isVolatile() {
            return _isVolatile;
        }

        public int getNextLiCounter() {
            return _liCounter++;
        }

        public String toString() {
            return "Subject SkipListNode: " + _resource + " isVolatile: " + _isVolatile;
        }
    }

    static class PropertyElement {
        /**
         * The property URI. *
         */
        private URIReference _uri;

        /**
         * An optional reification identifier. *
         */
        private URIReference _reificationURI;

        /**
         * An optional datatype. *
         */
        private String _datatype;

        /**
         * Flag indicating whether this PropertyElement has an
         * attribute <tt>rdf:parseType="Collection"</tt>.  *
         */
        private boolean _parseCollection;

        /**
         * The resource that was used to append the last part
         * of an rdf:List. *
         */
        private SubjectNode _lastListResource;

        PropertyElement(URIReference uri) {
            _uri = uri;
        }

        public URIReference getURI() {
            return _uri;
        }

        public boolean isReified() {
            return null != _reificationURI;
        }

        public void setReificationURI(URIReference reifURI) {
            _reificationURI = reifURI;
        }

        public URIReference getReificationURI() {
            return _reificationURI;
        }

        public void setDatatype(String datatype) {
            _datatype = datatype;
        }

        public String getDatatype() {
            return _datatype;
        }

        public boolean parseCollection() {
            return _parseCollection;
        }

        public void setParseCollection(boolean parseCollection) {
            _parseCollection = parseCollection;
        }

        public SubjectNode getLastListResource() {
            return _lastListResource;
        }

        public void setLastListResource(SubjectNode resource) {
            _lastListResource = resource;
        }

        public String toString() {
      return "URI: " + _uri + " datatype " + _datatype;
    }
  }
}
