<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content=
  "emacs and fingers" />
  <title>Querying the Semantic Web using a Relational Based SPARQL</title>
<style type="text/css">
/*<![CDATA[*/
pre.data	{ border: thin solid #88AA88;
                  background-color: #E8F0E8;
                  margin: 1em 4em 1em 0em ; }
table		{ margin: 10px }
/*]]>*/
</style>
</head>

<body>
  <div class="head">
    <h1 id="main">Querying the Semantic Web using a Relational Based SPARQL</h1>

    <dl>
	<dd>Andrew Newman</dd>
	<dd>The School of Information Technology and Electrical Engineering</dd>
	<dd>The University of Queensland</dd>
	<dd>Submitted for the degree of Bachelor of Information Technology (Honours)</dd>
	<dd>25th October 2006</dd>
	<dd>(Updated 7th November 2006)</dd>
    </dl>

  </div>
  <hr title="Separator for header" />

  <div>
    <h2 class="notoc"><a id="abstract">Abstract</a></h2>

    <p>The Semantic Web is an initiative that aims to enable data from different sources to be
combined in a consistent way. It is particularly useful when the schemas and terminologies of
different data sets are to be merged; they differ between organisations or change over time.
Semantic Web technologies have been successfully applied to data integration in fields such as
Bio-Informatics, Life Sciences, GIS (Geographic Information Systems) and Material Sciences.
Resource Description Framework (RDF) is a simple graph-based data model for representing
information on the Web. SPARQL is the proposed standard for querying RDF and both are
part of the W3C’s Semantic Web Activity.
</p>

    <p>The current SPARQL specification shows a strong bias towards underlying implementations
such as SQL and lacks a formal model. Previous work by Cyganiak, Frasincar et al., Harris
and Shadbolt, and Pérez et al. [<a href="#ref5">5</a>, <a href="#ref10">10</a>, <a href="#ref16">16</a>, <a href="#ref22">22</a>] has highlighted the need for a formal model in
order to improve consistency and clarity of the existing specification. A formal model would
also allow independence between implementation and specification, greater consistency with
RDF, and the ability to improve implementations without affecting the user’s view of the
system.
</p>

    <p>The relational model is a candidate for such a formal model as it is a mature formal model that
is well understood and provides other features such as efficient query optimisation and
distribution.
</p>

    <p>Building on previous work by Galindo-Legaria, this thesis provides a mapping from RDF and
SPARQL using the relational model and shows the desirable outcomes of such an approach.
The SPARQL operations UNION and OPTIONAL were implemented using the relational
operators outer union and minimum union respectively. Implementation details using the
JRDF library are described including the use of an order independent minimum union
implementation. Some of the advantages in applying pre-existing relational optimisation
techniques are explored.
</p>

    <p>It is shown that using the relational model as a basis for SPARQL provides an easier to
implement, more efficient, more consistent and extensible query language than is currently
provided. This approach allows the reuse of existing relational optimisation techniques and
can be used as a basis to extend SPARQL functionality.
</p>

  </div>

    <hr />

    <h2><a id="contents" name="contents">Table of Contents</a></h2>

    <ul>
      <li><a href="#Overview">1 Overview</a><ul>
	  <li><a href="#Introduction1">1.1 Introduction</a></li>
	</ul></li>
      <li><a href="#RelatedWork">2 Related Work</a><ul>
	  <li><a href="#Introduction2">2.1 Introduction</a></li>
	  <li><a href="#Model">2.2 Motivations for Creating a Formal Model</a></li>
	  <li><a href="#NULL">2.3 The Use of NULL</a></li>
	  <li><a href="#Duplicates">2.4 Duplicates</a></li>
	  <li><a href="#Semantics">2.5 Compositional vs Operational Semantics</a></li>
	  <li><a href="#Operator">2.6 The SPARQL OPTIONAL Operator</a></li>
	  <li><a href="#SPARQLOptimisations">2.7 Optimisations Applicable to SPARQL</a></li>
	  <li><a href="#SPARQL">2.8 Other Issues with SPARQL</a></li>
	</ul></li>
      <li><a href="#Methodology">3 Methodology</a></li>
      <li><a href="#Mapping">4 Mapping RDF to the Relational Model</a><ul>
	  <li><a href="#Example">4.1 Example</a></li>
	  <li><a href="#Types">4.2 RDF to Relational Types</a></li>
	  <li><a href="#Modifying">4.3 Modifying Relational Joins</a></li>
	  <li><a href="#Joins">4.4 Order Independent Joins</a></li>
	  <li><a href="#OptimisationEffects">4.5 Effect of Optimisation</a></li>
	</ul></li>
      <li><a href="#FutureWork">5 Future Work</a><ul>
	  <li><a href="#Extending">5.1 Extending the use of the Relational Model</a></li>
	  <li><a href="#Optimisations">5.2 Further Optimisations</a></li>
	  <li><a href="#SQL">5.3 A Minimum Union version of OPTIONAL Using SQL</a></li>
	</ul></li>
      <li><a href="#Conclusion">6 Conclusion</a></li>
      <li><a href="#References">References</a></li>
    </ul>

    <h2 id="Overview">1 Overview</h2>
    <h3 id="Introduction1">1.1 Introduction</h3>
<p>Resource Description Framework (RDF) is a part of the W3C’s Semantic Web initiative.
RDF is a simple graph-based data model for representing information on the Web [<a href="#ref18">18</a>]. It has
a formal data model, with formal semantics, and is designed to be simple, open, and extensible
[<a href="#ref18">18</a>]. An RDF graph is a set of triples; each triple is made of a Subject, Predicate and Object.
Triples are used to create relationships between the subject and object using different
predicates [<a href="#ref18">18</a>].</p>
<p>SPARQL (SPARQL Protocol And Query Language) is the W3C’s proposed standard for
querying RDF [<a href="#ref23">23</a>]. SPARQL is one of a number of query languages designed to query
formal representations of data such as XML (eXtensible Markup Language), Topic Maps
and RDF which consist of data models represented as trees, topics and associations, and
directed graphs respectively [<a href="#ref1">1</a>]. Similar to other query languages, SPARQL allows users to
declaratively specify the conditions required for data to be retrieved rather than explicitly
describing the individual steps required to return the data.
SPARQL provides definitions for:</p>
    <ul>
      <li>Simple matching of RDF data,</li>
      <li>The ability to combine multiple matches together,</li>
      <li>Matching data types such as integers, literals, etc. based on conditions such as greater than, equal to, etc.,</li>
      <li>Optionally matching data – that is, if certain data does exist it must meet a certain criteria but the query does not fail if the data doesn’t exist,</li>
      <li>Combining RDF data sets together to query at the same time, and</li>
      <li>Ordering and limiting matched data.</li>
    </ul>
<p>The definitions listed above are somewhat loose, however. SPARQL has yet to be described
formally using a set-based data model that follows RDF’s abstract model. A data model, as
defined by Date [<a href="#ref6">6</a>], “provides an abstract, self-contained, logical definition of data structures,
data operators and so forth, that together make up the abstract machine with which the user
interacts”.</p>
<p>Haase, et al. state that the “…underlying data model directly influences the set of operations
that should be provided by a query language” [<a href="#ref14">14</a>]. Furthermore, it is highlighted that the
design of an RDF query language should support [<a href="#ref14">14</a>]:</p>
<ul>
<li>The RDF abstract data model,</li>
<li>Formal semantics and inference,</li>
<li>XML schema data types and</li>
<li>The ability to handle incomplete or contradictory information.</li>
</ul>
<p>The beneficial properties of a query language for the Semantic Web defined by Bailey et al.
[<a href="#ref1">1</a>] include:</p>

<ul>
<li>Referentially transparent - “within the same scope, an expression always means the
same”,</li>
<li>Strong answer closure - the result of a query can be used as the input for further
querying,</li>
<li>Set-oriented functional – also known as a backtracking-free logic programming,</li>
<li>Incomplete queries and answers - support for data on the Web that may not have
defined schemas,</li>
<li>Multiple serialisation aware - able to serialise data to various formats including XML,
OWL, RDF and Topic Maps, and</li>
<li>Queries that support reasoning capabilities - the ability to query different data sources
and infer new statements.</li>
</ul>
<p>The relational model is an existing model that could be used to provide a compatible setbased,
formal model. This model has long been used as the basis for database management.
Date defines it as consisting of three components: structure, integrity and manipulation [<a href="#ref6">6</a>].
It has been extended to support rules and inferencing [<a href="#ref21">21</a>], support for XML schema data
types and other data types [<a href="#ref8">8</a>], to query hierarchical data [<a href="#ref9">9</a>] and to support merging data,
potentially incomplete or contradictory information, through the use of outer joins and other
techniques [<a href="#ref13">13</a>]. The relation model supports answer closure and referential transparency
(for read-only queries).</p>
<p>The set of relational operators combined with the relational model are collectively called the
relational algebra [<a href="#ref6">6</a>]. The operations on relations originally defined by Codd [<a href="#ref4">4</a>] include: set
operations, projection, join, Cartesian product, and restriction. It is from these original
operators that other relational operations have been derived including: restrict, project, join,
and union [<a href="#ref6">6</a>]. In SPARQL they are analogous with: triples matches, SELECT, ‘.’ (join), and
UNION.</p>
<p>An alternative to the relational model is SQL (Structured Query Language). SQL is often seen
as an implementation of the relational model even though it has numerous incompatibilities
with the relational model such as bag instead of set semantics, column ordering, duplicates and
handling of nulls [<a href="#ref6">6</a>]. SQL has been formally reconstructed using bags (a collection of values
that allow duplicates) rather than sets (a collection of values that allows no duplicates) [<a href="#ref20">20</a>].
From this work it’s shown that operations such as DISTINCT and aggregate functions are
only applicable for bags and not sets. SQL’s use of duplicate values can also cause problems
with both optimisation and query processing [<a href="#ref6">6</a>].</p>
<p>SQL also has other problems [<a href="#ref20">20</a>] such as,</p>
    <blockquote>
      <p>“…no one really knows what SQL is, since there are many different versions, it is widely
accepted that any version of SQL has at least two features which are not present in the
relational algebra: aggregate operators…[and it] allows a limited form of nesting by using
the GROUP-BY construct…one needs bag semantics for the correct evaluation of
aggregate functions.”</p>
    </blockquote>

<div id="page3"/>
<p>Software that depends on SQL frequently has to adapt to each vendor specific
implementation due to these differences.</p>
<p>Similarly, SQL’s UNION operator has a number of problems in that it relies on a column
ordering being used to match values rather than the columns being the same type (as defined
by relational algebra) [<a href="#ref7">7</a>]. Date claims, “…given any two SQL tables, there are typically
many distinct tables that can all be regarded as a union between two given SQL tables”.
The distinct differences between SQL and RDF are the reason why SQL is not a natural
choice as the basis of an RDF query language. It is clear than any formal SPARQL definition
should abstract away any dependence from SQL and be solely based on the data model it is
querying, RDF.</p>
<p>SQL does have a large industry following so it is crucial that a mapping from SPARQL to
SQL exists. Work on this mapping has already occurred [<a href="#ref2">2</a>], but further work, especially
using known SQL optimisation techniques [<a href="#ref19">19</a>], has yet to occur.</p>
<p>Previous work has highlighted specific limitations of the current SPARQL specification [<a href="#ref5">5</a>,
<a href="#ref10">10</a>, <a href="#ref16">16</a>, <a href="#ref22">22</a>] and subsequent implementations. To overcome these issues an underlying formal
model should be established. However, little work has been done in developing and evaluating
an RDF query language that is built on formal set-based models while maintaining a focus on
SPARQL.</p>
<p>As both the RDF model and the relational model are both propositional and set-based it is
likely that a compatible model for querying RDF can be provided. This should lead to two
direct advantages for users and implementers:</p>

<ol>
      <li>It provides a formal model that unambiguously outlines a consistent set of principles to
create a coherent foundation for the formulation of queries. This provides a stable set
of fundamentals that remain constant as implementations or syntaxes evolve over time.</li>
      <li>It allows the continuing work being done on the relational model to be applied to
querying RDF.</li>
</ol>

<div id="page4"/>
    <h2 id="RelatedWork">2 Related Work</h2>
    <h3 id="Introduction2">2.1 Introduction</h3>
<p>The main work to date dealing with mapping SPARQL to the relational model has been
motivated, in part, to efficiently answer queries. The use of NULL, duplicates and the order
in which operations are executed have been the main incompatibilities highlighted so far. With
a clear definition of SPARQL operations such as UNION and OPTIONAL, previous work
on efficient query implementations is highlighted.</p>
    <h3 id="Model">2.2 Motivations for Creating a Formal Model</h3>
<p>SPARQL has previously been compared and mapped to the relational model by Cyganiak [<a href="#ref5">5</a>],
and Harris and Shadbolt [<a href="#ref16">16</a>]. A shared motivation for these works has been to make
available the previous experience dealing with query planning and optimisation. Harris
specifically mentions that RDF implementations do not take advantage of database engines’
built in query optimisers and knowledge of indexes [<a href="#ref16">16</a>].</p>
<p>Pérez et al. [<a href="#ref22">22</a>] developed a formal model in an attempt to remove any redundancy or
contradictions within the SPARQL specification. They also shared a similar motivation with
previous relational mapping work, to reuse existing work on query planning and optimisation.
Along similar lines, the paper by Frasincar et al. [<a href="#ref10">10</a>] when rationalizing the requirement for
an RDF algebra stated that issues of query optimisation “are mostly neglected”. The types
of optimisation proposed by Frasincar et al. included efficiently performing extraction of data
and constructing results [<a href="#ref10">10</a>].</p>
    <h3 id="NULL">2.3 The Use of NULL</h3>
<p>Cyganiak and Pérez et al. both note that unbound (or NULL values) in SPARQL lead to
several inconsistencies with the relational model. Cyganiak says, “The SPARQL model does
not, for example, distinguish between an OPTIONAL variable that is unbound in some
solutions, and a variable that is not used in the query at all.” This result leads to confusion as
to what an unbound result means.</p>
<p>A parallel occurs in SQL databases through the use of NULLs to indicate missing information
[<a href="#ref6">6</a>]. The issue related to NULL values has been debated by Date and Codd [<a href="#ref6">6</a>], “nulls have
no place in the relational model.” NULLs can have a direct impact on practical applications.
For example, Henly [<a href="#ref17">17</a>] has applied criticism of NULLs to the field of geoscience and notes
that NULL information can be caused by multiple reasons such as “not worthy of comment”,
“to be added later”, “lost”, or indicates that the value is between known ranges but has not
registered significantly to be recorded.</p>

<div id="page5"/>
    <h3 id="Duplicates">2.4 Duplicates</h3>
<p>The existence and semantics of SPARQL operations such as DISTINCT and UNION appear
to be based on underlying implementations, especially SQL, rather than following RDF
semantics. RDF semantics clearly define sets of statements that express a proposition [<a href="#ref18">18</a>].
SPARQL, on the other hand, describes the possibility of duplicates and it makes no guarantee
of a consistent approach to returning duplicates [<a href="#ref23">23</a>]. The same duplicate proposition is a
tautology, “If something is true, saying it twice doesn’t make it any more true.” [<a href="#ref6">6</a>].
Date’s main prescription against duplicates [<a href="#ref6">6</a>] is: “…certain expression transformations, and
hence certain optimizations, that are valid in a relational context are not valid in the presence
of duplicates.” He presents [<a href="#ref6">6</a>] twelve different queries that produce nine different results
each with their own degree of duplication. He concludes that, “you should always ensure
that query results contain no duplicates…by always specifying DISTINCT in your SQL
queries…if you follow this advice…there’s no good reason for allowing duplicates”.</p>
    <h3 id="Semantics">2.5 Compositional vs Operational Semantics</h3>
<p>A lot of work has been done since the inception of the relational model [<a href="#ref24">24</a>]. The foundation
of this work has been accomplished by constructing operator trees to define a search space.
The search space is explored for the most efficient operations by replacing operations with
equivalent ones or by changing the order of execution. This is generally possible because of
mathematical properties of the relational operators such as commutativity and associativity.
In traditional optimisers such as System-R and Starburst a cost model of the query is created,
operations are optimised and performed in a bottom-up fashion [<a href="#ref24">24</a>].</p>
<p>The work of Pérez et al. [<a href="#ref22">22</a>] highlights the distinction in SPARQL between two ways of
executing queries: compositional and operational. Operational semantics consists of executing
“a depth-first traversal of the parse tree of P and the use of the intermediate results to avoid
some computations.” An example given is that the query (A OPT (B OPT C)) is executed by
first executing A then B and then C. In other words, operational semantics executes a query
in a left-to-right, top-to-bottom order. Compositional semantics executes the queries in a
bottom-up order of execution. This would mean that the inner part of the example query, (B
OPT C), is executed first.</p>
<p>Both Pérez and Cyganiak discuss the use of compositional over operational semantics when
evaluating SPARQL queries. This choice of execution order is especially important for
determining what the correct results of variables used both inside and outside of constraints
that include an OPTIONAL clause (Cyganiak refers to it as “The “Nested OPTIONALs”
Problem” [<a href="#ref5">5</a>]).</p>
<p>As relational implementations are based on compositional semantics, the rejection will reduce
the ability to apply existing relational optimisation techniques. Processing query expressions
to their conjunctive or disjunctive form for simplification and reordering is largely prevented
as it depends on operations being associative and commutative.</p>

<div id="page6"/>
    <h3 id="Operator">2.6 The SPARQL OPTIONAL Operator</h3>
<p>SPARQL’s OPTIONAL operator as defined by Harris [<a href="#ref16">16</a>] “…is used to signify a subset of
the query that should not cause the result to fail if it cannot be satisfied…it is roughly
analogous to the left outer join of relational algebra.” Cyganiak [<a href="#ref5">5</a>] has shown that the
semantics of OPTIONAL is not compatible with relational algebra. SPARQL provides “only
conflicts cause join failure” whereas relational algebra provides “unbound variable causes join
failure”. This relationship with left outer join indicates a similar order dependency for
OPTIONAL.</p>
<p>The OPTIONAL functionality in SPARQL is similar to the outer join feature implemented in
Edutella, a peer-to-peer based system for performing distributed RDF searches [<a href="#ref21">21</a>]. Edutella
is based on Datalog that adds inference rules to relational databases,
“Outer join between R and S gives us all the tuples, whether they have matching tuples in
the other relation or not. In outer join all the answers terminate in true. You never get an
empty answer. In cases where you ask questions with many variables and some do not
match, you get an answer, but the result for those variables that did not match are filled by
NULL.”</p>
<p>It was found that “inconsistencies in the answers depend on which order the outer join body
literals are interpreted in.” It is clear that order dependency in executing queries leads to
inefficient distribution and uncertainty in which results will be returned from a query.</p>
    <h3 id="SPARQLOptimisations">2.7 Optimisations Applicable to SPARQL</h3>
<p>A solution to efficiently and unambiguously implementing outer joins in relational algebra was
presented by Galindo-Legaria [<a href="#ref12">12</a>]. It includes a “hierarchical view of data…where relational
attributes may be set-based…” and “Instead of having one tuple with parent-child
information for each child, we present the children as a set associated with the parent.” This
has the advantage of removing the requirement for NULLs as place fillers when tables of
different attributes are operated on. Instead, tuples contain sets of values for only those that
are found or “…tuples in a relation may be defined on different sets of attributes, as long as
they are a subset of the relation scheme”.</p>
<p>The relational UNION operator was extended to be “untyped” (able to join on unequal
relation schemes) called outer union [<a href="#ref11">11</a>]. The use of an outer union operation provides the
similar semantics to SPARQL’s UNION and is consistent with SPARQL’s “only conflicts
cause join failure” [<a href="#ref5">5</a>]. It also provides a formal, unambiguous definition of the operation.
Galindo-Legaria has shown that outer join can be implemented using minimum union to form
join-disjunctive queries. The advantages are that “disjunction is commutative and associative,
which is a significant property for intuition, formalisms, and generation of execution plans”
[<a href="#ref11">11</a>].</p>
<p>The applicability of this using the approach suggested by Galindo-Legaria and Rosenthal was
rejected by Pérez et al.:</p>
    <blockquote>
      <p>“…classical results about outer join query reordering and optimization by Galindo7
Legaria and Rosenthal are not directly applicable in the SPARQL context because they
assume constraints on the relational queries that are rarely found in SPARQL…the
assumption on predicates used for joining (outer joining) relations to be null-rejecting.
In SPARQL, those predicates are implicit in the variables that the graph patterns share
and by the definition of compatible mappings they are never null-rejecting…the queries
are also enforced not to contain Cartesian products, situation that occurs often in
SPARQL when joining graph patterns that do not share variables. Thus, specific
techniques must be developed in the SPARQL context.”
</p>
    </blockquote>
<p>It should be noted that the work of Galindo-Legaria forms the main basis of this thesis and
contrasts with the claims made by Pérez et al. It is correct to state that simplification based
on null rejection has not been used. This does not prevent optimising outer joins through
tuple subsumption or using the definition of UNION proposed by Galindo-Legaria;
specifically it allows unbound or NULL values within a tuple. Furthermore, it seems
premature to discard the use of null rejection simplification in queries as it maybe possible to
reuse these techniques by treating intermediate results using a slightly non-traditional
approach. This approach is discussed in future work.</p>
<p>Another difference between Pérez et al. and Galindo-Legaria is the definition of left outer join.
In Pérez et al. it is defined as:</p>
    <p class="formula">Ω1 <img src="u27D5.png" alt="left outer join" height="15" width="15"/> Ω2 = (Ω1 <img src="u22C8.png" alt="join" height="15" width="15"/> Ω2) ∪ (Ω1 ∖ Ω2)</p>
<p>Where Ω is a set of mappings, where a mapping is a partial function of variables (V) to tuples
(T). Tuples (T) consist of the positional elements subject (v1), predicate (v2) and object (v3)
of an RDF statement.</p>
<p>Galindo-Legaria [<a href="#ref12">12</a>] defines left outer join of two relations R1 and R2 as:</p>
    <p class="formula">R1 <img src="u27D5.png" alt="left outer join" height="15" width="15"/> R2 := (R1 <img src="u22C8.png" alt="join" height="15" width="15"/> R2) <img src="u228E.png" alt="outer union" height="15" width="15"/> (R1 <img src="u22B3.png" alt="antijoin" height="15" width="15"/> R2)</p>
<p>Where, ⋈ is the join of R1 and R2 on some predicate, <img src="u228E.png" alt="outer union" height="15" width="15"/> is outer union and <img src="u22B3.png" alt="antijoin" height="15" width="15"/> is antijoin.
Antijoin is defined as:</p>
    <p class="formula">R1 <img src="u22B3.png" alt="antijoin" height="15" width="15"/> R2 := R1 <img src="uFF0D.png" alt="minus" height="15" width="15"/> (R1 <img src="u22C9.png" alt="semijoin" height="15" width="15"/> R2)</p>
<p>This is the difference between R1 and the result of the semijoin (<img src="u22C9.png" alt="semijoin" height="15" width="15"/>) of R1 and R2. Where
semijoin is:</p>
    <p class="formula">R1 <img src="u22C9.png" alt="semijoin" height="15" width="15"/> R2 := π(R1) (R1 <img src="u22C8.png" alt="join" height="15" width="15"/> R2)</p>
<p>Where π(R1) is project on R1 from the results of <img src="u22C9.png" alt="semijoin" height="15" width="15"/> the join of R1 and R2.</p>
<p>The important distinction to make is that Pérez et al.’s definition uses the difference between
two sets of tuples (∖) rather than the antijoin. In Appendix A.5, Lemma 3 of [<a href="#ref22">22</a>] it is shown
that:</p>
    <p class="formula">(Ω1 ∖ Ω2) = Ω1 ∖ (Ω1 <img src="u22C8.png" alt="join" height="15" width="15"/> Ω2)</p>

<div id="page8"/>
<p>The expanded version of left outer join becomes:</p>
    <p class="formula">Ω1 <img src="u27D5.png" alt="left outer join" height="15" width="15"/> Ω2 = (Ω1 <img src="u22C8.png" alt="join" height="15" width="15"/> Ω2) ∪ (Ω1 ∖ (Ω1 <img src="u22C8.png" alt="join" height="15" width="15"/> Ω2))</p>
<p>While Galindo-Legaria’s left outer join with antijoin and semijoin expanded becomes:</p>
    <p class="formula">R1 <img src="u27D5.png" alt="left outer join" height="15" width="15"/> R2 := (R1 <img src="u22C8.png" alt="join" height="15" width="15"/> R2) <img src="u228E.png" alt="outer union" height="15" width="15"/> (R1 − (π(R1) (R1 <img src="u22C9.png" alt="semijoin" height="15" width="15"/> R2)))</p>
<p>The only difference is the use of semijoin over join. While both of these operations produce
the same overall result for left outer join, the use of semijoin is considered superior from the
point of view of efficiency. This is highlighted by Galindo -Legaria [<a href="#ref12">12</a>]:</p>

    <blockquote><p>”Since the join of relations R1, R2 applies some match predicate, it may not preserve all
tuples from its arguments…This observations is the basis of some query processing
algorithms to “reduce” relations…”</p></blockquote>
<p>Another simpler version of performing minimum union was also presented by Galindo-
Legaria [<a href="#ref11">11</a>]. Instead of performing a series of operations that includes project, join, and
antijoin, an approach using outer union followed by tuple subsumption called minimum
union, was suggested. Minimum union is both commutative and associative and has a lower
precedence than join. This is similar to the assertion in Pérez et al. that SPARQL’s
OPTIONAL has a lower precedence than its join operation [<a href="#ref22">22</a>].</p>
<p>Tuple subsumption is defined as t1 subsumes t2 if t1 has more values that are not null than t2
and that the values in t2 that are not null are equal to t1. The removal of subsumed tuples in R
is denoted as R↓ <!-- was ￬ -->. The minimum union of R1 and R2 is defined as:</p>
      <p class="formula">R1 ⊕ R2 := (R1 <img src="u228E.png" alt="outer union" height="15" width="15"/> R2) ↓</p>
<p>Left outer join of R1 and R2 is then defined as:</p>
      <p class="formula">R1 <img src="u27D5.png" alt="left outer join" height="15" width="15"/> R2 := R1 <img src="u22C8.png" alt="join" height="15" width="15"/> R2 ⊕ R1</p>
    <h3 id="SPARQL">2.8 Other Issues with SPARQL</h3>
<p>Harris [<a href="#ref16">16</a>] defines three other cases where the relational model will have problems processing
value constraints - specifically within FILTER operations. They are:</p>
<ul>
<li>Non-relational expressions such as regular expressions,</li>
<li>Late bound expressions where variables are created outside their local blocks and</li>
<li>Placing constraints in a required block on variables that are only bound in an
OPTIONAL block.</li>
</ul>
<p>Similarly, Cyganiak [<a href="#ref5">5</a>] defines a problem for relational algebra where a selection, for example
during a FILTER operation, can only access variables within it’s own block.</p>

<div id="page9"/>
    <h2 id="Methodology">3 Methodology</h2>
<p>The feasibility of providing a formal model of SPARQL using the relational model will be
explored by:</p>
<ul>
<li>Demonstrating how SPARQL operations can be adapted to use the relational model,</li>
<li>Extending the relational model using previously discovered methods,</li>
<li>Developing a working prototype, and</li>
<li>Comparing the working prototype with another SPARQL implementation.</li>
</ul>
<p>SPARQL defines a series of operations, use cases and semantics. These were adapted to be
consistent with an extended relational model and the operations of relational algebra. The
mappings will then be contrasted with the existing SPARQL operations and any benefits
associated will be highlighted.</p>
<p>The prototype query engine and user interface was developed to allow queries to be
processed. The prototype is written using Java 5.0 and includes a user interface developed in
the Java Swing API. This query engine was implemented using the RDF library, JRDF. This
will include making the following modifications:</p>
<ul>
<li>Mappings from the RDF model to the relational model,</li>
<li>Creating a SPARQL parser,</li>
<li>Relational constructs such as attributes, tuples and relations,</li>
<li>Implementing the relational operations (Project, Restrict, Join, Union, Semidifference and Antijoin),</li>
<li>Creating a Swing user interface,</li>
<li>Adding the ability to execute relational operations in any order,</li>
<li>Performing SPARQL queries using the relational operations including extending the
relational algebra to allow querying of missing data provided by the SPARQL
operation OPTIONAL, and</li>
<li>Creation of tests to validate SPARQL compliance.</li>
</ul>
<p>This considerably increased the complexity of JRDF with the number of Java classes required
for implementation increased by nearly a factory of two from 155 to 292. There was an
addition of approximately 15,000 lines of code from an existing base of 21,000 with an
increase from 4857 to 9035 NCSS (Non Commenting Source Statements).
A comparative review is provided between the developed relational system using JRDF and
Hewlett Packard’s Jena library.</p>
<p>The sample data, based on FOAF data set and queries provided by the SPARQL test cases is
used to show the practical advantages of implementing a query engine in this way.</p>

<div id="page10"/>
    <h2 id="Mapping">4 Mapping RDF to the Relational Model</h2>
<p>An initial investigation into extending the relational model to store and query RDF has been
performed, with the purpose of ascertaining the practicality of using the relational model to
make simple queries of RDF data.</p>
<p>In order to create a simple example of representing the RDF model in the relational model, the
components of the various systems must be clearly defined and contrasted. These various
components include:</p>
<ul>
<li>A concrete interpretation of a RDF graph - Each node in a graph, URI, Literal or
bnode, is considered distinct if it has different values by character comparison or
identity in the case of bnodes.</li>
<li>The relational model - Consisting of Types, Attribute Names, Attributes, Tuples,
Headings and Relations.</li>
<li>Relational Operators - A small selection including: Restrict, Project and Join.</li>
<li>The RDF model - Consisting of RDF triples that can further be broken down into
positional elements: Subject, Predicate and Object. Each of the positional elements
can be of a certain type. Subjects are either URI References or blank nodes; predicates
must be URI References; and objects can be URI References, blank nodes or literals.</li>
</ul>
<p>The following figure shows node value types: URI Reference (URI/IRI), blank node (BNode)
and literal extend the positional types: Subject, Predicate and Object.</p>
    <p><img src="UML Class Diagram.jpg" width="487" height="243" alt="A UML Class Diagram of RDF Nodes and Types in JRDF"/><br/>
Figure 1. A UML Class Diagram of RDF Nodes and Types in JRDF.</p>
<p>Using this hierarchy of node types we can create a mapping between the relational and RDF
components, as shown in the following table:</p>

<div id="page11"/>
    <table border="1">
      <caption>Table 1. RDF and Relational Components</caption>
      <thead>
	<tr><th>Component Name</th><th>Description</th><th>Relational</th><th>RDF/SPARQL</th></tr>
      </thead>
      <tbody>
	<tr><td>Type Name</td><td>A data type</td><td>integer, char, sno, name</td><td>subject, predicate, object, uri, literal and bnode</td></tr>
	<tr><td>Attribute Name</td><td>A distinct, descriptive name</td><td>status, city, sno, sname</td><td>Variables: ?s, ?city<hr/>Node Postions: subject, predicate, object</td></tr>
	<tr><td>Attribute</td><td>A combination of type name and attribute name</td><td>status:integer, char:city, sno:sno, sname:name</td><td>?s:subject, p1:predicate, ?city:object</td></tr>
	<tr><td>Tuple or Tuple Value</td><td>A set of attribute and value pairs</td><td>sno sno(‘s1’), sname name(‘smith’), status 20, city ‘london’</td><td>?s:subject(#s1), p1:predicate(#name), o1:object(‘smith’)</td></tr>
	<tr><td>Heading</td><td>A set of attributes</td><td>sno sno, sname name, status integer, city char</td><td>?s subject, p1 predicate, o1 object</td></tr>
      </tbody>
    </table>

<p>A relation contains a heading and a body. The body contains a set of tuples and as defined by
Galindo-Legaria, “tuples in a relation may be defined on different set of attributes, as long as
they are a subset of the relation schema.” [<a href="#ref12">12</a>].</p>
    <h3 id="Example">4.1 Example</h3>
<p>The following is a walk-through using the relational operations on RDF to produce the same
results that are given by the SPARQL specification.</p>
<p>Using a limited set of sample tuples from the typical supplier and part examples given by
Date [<a href="#ref6">6</a>] the following relations can be created:</p>
		<div>
    <table style="float: left" border="1">
      <caption>Suppliers</caption>
      <thead>
	<tr><th>sno:sno</th><th>sp:sp</th></tr>
      </thead>
      <tbody>
	<tr><td>Supplier1</td><td>Parts1</td></tr>
	<tr><td>Supplier1</td><td>Parts2</td></tr>
	<tr><td>Supplier2</td><td>Parts1</td></tr>
	<tr><td>Supplier2</td><td>Parts2</td></tr>
      </tbody>
    </table>

    <table border="1">
      <caption>Parts</caption>
      <thead>
	<tr><th>sp:sp</th><th>char:city</th></tr>
      </thead>
      <tbody>
	<tr><td>Parts1</td><td>‘London’</td></tr>
	<tr><td>Parts2</td><td>‘Paris’</td></tr>
      </tbody>
    </table>
</div>  
 
<p style="clear: both">A similar representation using relations modified to use RDF components (RDF relations) is

<a id="page12"/>
shown below:</p>
    <table border="1">
      <caption>Suppliers and Parts</caption>
      <thead>
	<tr><th>s1:subject</th><th>p1:predicate</th><th>o1:object</th></tr>
      </thead>
      <tbody>
	<tr><td>Supplier1</td><td>#sno</td><td>Supplier1*</td></tr>
	<tr><td>Supplier1</td><td>#sp</td><td>Parts1</td></tr>
	<tr><td>Supplier1</td><td>#sp</td><td>Parts2</td></tr>
	<tr><td>Suppler2</td><td>#sno</td><td>Supplier2*</td></tr>
	<tr><td>Suppler2</td><td>#sp</td><td>Parts1</td></tr>
	<tr><td>Suppler2</td><td>#sp</td><td>Parts2</td></tr>
	<tr><td>Parts1</td><td>#sp</td><td>Parts1*</td></tr>
	<tr><td>Parts2</td><td>#sp</td><td>Parts2*</td></tr>
	<tr><td>Parts1</td><td>#city</td><td>‘London’</td></tr>
	<tr><td>Parts2</td><td>#city</td><td>‘Paris’</td></tr>
      </tbody>
    </table>

<p>* Alternatively, Supplier1 and Parts1 as Subjects maybe modified to use blank nodes instead.</p>
<p>A sample SPARQL query can be devised to return all the supplier numbers (sno), part
numbers (pno) and cities.</p>
<h4>Sample Query</h4>
    <pre>SELECT ?sno ?pno ?city
WHERE {
  ?sno #sno Supplier1 .
  ?sno #sp ?pno .
  ?pno #city ?city
}
</pre>
<p>This results in the following relations being created for each constraint (using a relational
restrict operation).</p>

<div id="page13"/>
		  <div style="float: left">
    <table border="1">
      <caption>Relation 1 (?sno #sno Supplier1)</caption>
	<tr><th>?sno:subject</th><th>p1:predicate</th><th>o1:object</th></tr>
	<tr><td>Supplier1</td><td>#sno</td><td>Supplier1</td></tr>
    </table>

    <table border="1">
      <caption>Relation 3 (?pno #city ?city)</caption>
	<tr><th>?pno:subject</th><th>p3:predicate</th><th>?city:object</th></tr>
	<tr><td>Part1</td><td>#city</td><td>‘London’</td></tr>
	<tr><td>Part2</td><td>#city</td><td>‘Paris’</td></tr>
    </table>
</div>
    <table border="1">
      <caption>Relation 2 (?sno #sp ?pno)</caption>
	<tr><th>?sno:subject</th><th>p2:predicate</th><th>?pno:object</th></tr>
	<tr><td>Supplier1</td><td>#sp</td><td>Part1</td></tr>
	<tr><td>Supplier1</td><td>#sp</td><td>Part2</td></tr>
	<tr><td>Supplier2</td><td>#sp</td><td>Part1</td></tr>
	<tr><td>Supplier2</td><td>#sp</td><td>Part2</td></tr>
	<tr><td>Part1</td><td>#sp</td><td>Part1</td></tr>
	<tr><td>Part2</td><td>#sp</td><td>Part2</td></tr>
    </table>

<p style="clear: both">By performing joins the following results are obtained:</p>

    <table border="1">
      <caption>Join Relation 1 and Relation 2</caption>
	<tr><th>?sno:subject</th><th>p1:predicate</th><th>o1:object</th><th>p2:predicate</th><th>?pno:object</th></tr>
	<tr><td>Supplier1</td><td>#sno</td><td>Supplier1</td><td>#sno</td><td>Part1</td></tr>
	<tr><td>Supplier1</td><td>#sno</td><td>Supplier1</td><td>#sno</td><td>Part2</td></tr>
    </table>

    <table border="1">
      <caption>Join of Relation 1, 2 and 3</caption>
	<tr><th>?sno:subject</th><th>p1:predicate</th><th>o1:object</th><th>p2:predicate</th><th>?pno:object</th><th>p3:predicate</th><th>?city:object</th></tr>
	<tr><td>Supplier1</td><td>#sno</td><td>Supplier1</td><td>#sno</td><td>Part1</td><td>#city</td><td>‘London’</td></tr>
	<tr><td>Supplier1</td><td>#sno</td><td>Supplier1</td><td>#sno</td><td>Part2</td><td>#city</td><td>‘Paris’</td></tr>
    </table>

<p>Using the relational project to produce only the variables defined in the SELECT part of the
SPARQL query the final result is:</p>

    <table border="1">
      <caption>Query Result</caption>
	<tr><th>?sno:subject</th><th>?pno:object</th><th>?city:object</th></tr>
	<tr><td>Supplier1</td><td>Part1</td><td>‘London’</td></tr>
	<tr><td>Supplier1</td><td>Part2</td><td>‘Paris’</td></tr>
    </table>

<p>This is consistent with the expected result when performing a SPARQL query using current
SPARQL implementations.</p>
    <h3 id="Types">4.2 RDF to Relational Types</h3>
<p>JRDF’s query layer consists of a NodeType interface used to indicate the type of an
attribute. It consists of a “composedOf” method that returns a set of node types. The node
types supported consist of RDF positional types (SubjectNodeType, PredicateNodeType

<a id="page14"/>
and ObjectNodeType), composite positional types (such as SubjectPredicateNodeType and
all other unique combinations) and value types (BlankNodeType, LiteralNodeType and
URIReferenceNodeType).</p>
<p>One of the first designs proposed to be used in JRDF was to calculate compositional nodes 
during joins.  When two relations were joined and a variable appeared in two different places, 
a new node type was derived. For example, the join of two relations on a variable that appears 
both as a subject and a predicate results in it being associated with a new type
“subjectpredicate”. Where, “subjectpredicate” is a composite type made of a subject and
predicate node type.</p>
<p>The current solution however, is to evaluate the query, record where the variables are being
used in the query, and associate composite types to any variables located in more than one
place. This process was adapted from an existing one where a check was being performed to
ensure that all the variables in the SELECT clause are bound in the WHERE clause. This
means that the join code does not have to infer new attribute types and the composite types
are used up front when performing restrict operations.</p>
    <h3 id="Modifying">4.3 Modifying Relational Joins</h3>
<p>Two different types of joins, extensions of the original relational operations, were required for
SPARQL support:</p>
<ul>
<li>Outer union - is a union that does not require both relations to be of the same
matching headings or types.</li>
<li>A null accepting join operation - relations of different types may be joined and a tuple
is only rejected if bound variables have differing values.</li>
</ul>
<p>The removal of matching types for union and a null accepting join may not seem to be
initially compatible with the relational model. However, it is merely a convenience, and it is
simply a combination of two or more relations. The following is an example of several
minimum union operations as described on page 4 of Galindo-Legaria [<a href="#ref11">11</a>]:</p>
    <table border="1">
	<tr><th>CUSTOMERS</th><th>ORDERS</th><th>ITEMS’</th></tr>
	<tr><td>C</td><td>O</td><td>I</td></tr>
	<tr><td>C</td><td>O</td><td>-</td></tr>
	<tr><td>C</td><td>-</td><td>-</td></tr>
    </table>

<p>This shows the result where the first row represents customers with orders for items,
followed by customers with orders and then customers without orders. As described in the
paper, projecting based on the required predicates can retrieve relations of the same type.
Essentially, this is a representation of three traditional relations.</p>
<p>From this perspective, a null accepting join can be seen as an optimisation for
performing operations on multiple relations in one pass.</p>
<p>The number of arguments, or arity, of operators in SPARQL is another example where the

<a id="page15"/>
definition of operators is unclear. For example Pérez et al. [<a href="#ref22">22</a>] says, “using the
binary operators UNION, AND and OPT, and FILTER”, even though OPTIONAL is nadic
(it has 1 or more parameters) in SPARQL. In Tutorial D and the relational algebra defined by
Date [<a href="#ref6">6</a>], join and union are both nadic. The associative nature of left outer join and hence the
mapping of OPTIONAL to relational algebra (that does not allow order specified in its nadic
operations) means there is a slight implementation difficulty. In JRDF, OPTIONAL
operations are turned into a series of dyadic operations and if a monadic OPTIONAL
operation is used it simply returns the initial binding.</p>
<p>Even though it is unclear if SPARQL’s JOIN and OPTIONAL are truly nadic, JRDF
supports nadic versions of these operations. In order to provide this support it requires the
equivalent of TABLE_DEE (true) and TABLE_DUM (false) (the two 0 degree or nullary
relations) to be defined. TABLE_DEE is the relation that contains one row, is analogous to
true and is the identity with respect to JOIN. TABLE_DUM is the relation that contains no
rows and is analogous to false. This also allows questions that result in a yes/no or true/false
result to be returned.</p>
<p>The minimum union of TABLE_DEE and another relation is always just that relation. Using
relational algebra the various combinations of the nullary relations (TABLE_DEE and
TABLE_DUM or in JRDF RelationDEE and RelationDUM) in SPARQL operations are:</p>
    <table style="float: left" border="1">
      <caption>SPARQL Join</caption>
	<tr><th></th><th>DEE</th><th>DUM</th><th>Relation</th></tr>
	<tr><td>DEE</td><td>DEE</td><td>DUM</td><td>Relation</td></tr>
	<tr><td>DUM</td><td>DUM</td><td>DUM</td><td>DUM</td></tr>
	<tr><td>Relation</td><td>Relation</td><td>DUM</td><td>Relation</td></tr>
    </table>

    <table border="1">
      <caption>SPARQL Union</caption>
	<tr><th></th><th>DEE</th><th>DUM</th><th>Relation</th></tr>
	<tr><td>DEE</td><td>DEE</td><td>DEE</td><td>DEE</td></tr>
	<tr><td>DUM</td><td>DEE</td><td>DUM</td><td>Relation</td></tr>
	<tr><td>Relation</td><td>DEE</td><td>Relation</td><td>Relation</td></tr>
    </table>

    <table style="clear: both" border="1">
      <caption>SPARQL Optional</caption>
	<tr><th></th><th>DEE</th><th>DUM</th><th>Relation</th></tr>
	<tr><td>DEE</td><td>DEE</td><td>DEE</td><td>DEE</td></tr>
	<tr><td>DUM</td><td>DUM</td><td>DUM</td><td>DUM</td></tr>
	<tr><td>Relation</td><td>Relation</td><td>Relation</td><td>Relation</td></tr>
    </table>
    <h3 id="Joins">4.4 Order Independent Joins</h3>
<p>An alternative version of OPTIONAL that was order independent but had similar semantics
to OPTIONAL was investigated. As a suitable example, data was combined from FOAF
files: http://clark.dallas.tx.us/kendall/foaf.rdf and http://eikeon.com/foaf.rdf. Sample queries
were performed first following SPARQL semantics and then following the order independent
semantics. For example, the query:</p>

<div id="page16"/>
<pre>SELECT ?name ?mbox ?nick
WHERE {
  ?x &lt;http://xmlns.com/foaf/0.1/name&gt; ?name .
  OPTIONAL {
    ?x &lt;http://xmlns.com/foaf/0.1/nick&gt; ?nick
    OPTIONAL {
      ?x &lt;http://xmlns.com/foaf/0.1/mbox&gt; ?mbox
    }
  }
}</pre>

<p>Using standard SPARQL semantics it produces:</p>

    <table border="1">
	<tr><th>?name:object</th><th>?mbox:object</th><th>?nick:object</th></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kclark@ntlug.org</td><td>“k”</td></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kclark@ntlug.org</td><td>“kclark”</td></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kclark@ntlug.org</td><td>“kendallc”</td></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kendall@monkeyfist.com</td><td>“k”</td></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kendall@monkeyfist.com</td><td>“kclark”</td></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kendall@monkeyfist.com</td><td>“kendallc”</td></tr>
	<tr><td>“Daniel Krech”</td><td></td><td>“eikon”</td></tr>
    </table>

<p>However, changing the order of the mbox and nick constraints produces a different result:</p>
<pre>SELECT ?name ?mbox ?nick
WHERE {
  ?x &lt;http://xmlns.com/foaf/0.1/name&gt; ?name .
  OPTIONAL {
    ?x &lt;http://xmlns.com/foaf/0.1/mbox&gt; ?mbox
    OPTIONAL {
      ?x &lt;http://xmlns.com/foaf/0.1/nick&gt; ?nick
    }
  }
}</pre>

      <table border="1">
	<tr><th>?name:object</th><th>?mbox:object</th><th>?nick:object</th></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kclark@ntlug.org</td><td>“k”</td></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kclark@ntlug.org</td><td>“kclark”</td></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kclark@ntlug.org</td><td>“kendallc”</td></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kendall@monkeyfist.com</td><td>“k”</td></tr>


	<tr><td><a id="page17"/>“Kendall Grant Clark”</td><td>mailto:kendall@monkeyfist.com</td><td>“kclark”</td></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kendall@monkeyfist.com</td><td>“kendallc”</td></tr>
	<tr><td>“Daniel Krech”</td><td></td><td></td></tr>
    </table>

<p>The important distinction to make is that the last row does not contain the nickname “eikon”
- this is the expected behaviour.</p>
<p>If full outer join is used as the implementation behind the OPTIONAL operation then it is no
longer order dependent. In turn, this provides the user with an easier way to express their
requirements. The drawback to full outer join is that it produces results that contain a large
number of more sparsely populated rows. Using the previous two queries the rows returned
have mboxes and no name or just nicknames. Using the previous query the results are:</p>

    <table border="1">
	<tr><th>?name:object</th><th>?mbox:object</th><th>?nick:object</th></tr>
	<tr><td></td><td></td><td>“eikon”</td></tr>
	<tr><td>“Daniel</td><td>Krech”</td><td>“eikon”</td></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kclark@ntlug.org</td><td>“k”</td></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kclark@ntlug.org</td><td>“kclark”</td></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kclark@ntlug.org</td><td>“kendallc”</td></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kendall@monkeyfist.com</td><td>“k”</td></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kendall@monkeyfist.com</td><td>“kclark”</td></tr>
	<tr><td>“Kendall Grant Clark”</td><td>mailto:kendall@monkeyfist.com</td><td>“kendallc”</td></tr>
	<tr><td></td><td></td><td>mailto:benkoo@ntr.net</td></tr>
	<tr><td></td><td></td><td>mailto:bparsia@email.unc.edu</td></tr>
	<tr><td></td><td></td><td>mailto:danbri@w3.org</td></tr>
	<tr><td></td><td></td><td>mailto:edd@usefulinc.com</td></tr>
	<tr><td></td><td></td><td>mailto:eikeon@eikeon.com</td></tr>
	<tr><td></td><td></td><td>mailto:em@w3.org</td></tr>
	<tr><td></td><td></td><td>mailto:gwachob@wachob.com</td></tr>
	<tr><td></td><td></td><td>mailto:jim@jibbering.com</td></tr>
	<tr><td></td><td></td><td>mailto:kendall@monkeyfist.com</td></tr>
	<tr><td></td><td></td><td>mailto:khampton@totalcinema.com</td></tr>
	<tr><td></td><td></td><td>mailto:libby.miller@bristol.ac.uk</td></tr>
	<tr><td></td><td></td><td>mailto:me@aaronsw.com</td></tr>
	<tr><td></td><td></td><td>mailto:niel@bornstein.atlanta.ga.us</td></tr>
	<tr><td></td><td></td><td>mailto:uche.ogbuji@fourthought.com</td></tr>
    </table>

<div id="page18"/>
<p>Note the rows with the values of “eikon” or “mailto:kendall@monkeyfist.com” which have
the same bound values as other result but have more unbound values than other results
returned. Subsumption can be used in order to remove these tuples.</p>
<p>The subsumption algorithm used in JRDF’s implementation was implemented by modifying
the join algorithm. A tuple from the left hand side of the join was compared with each of the
tuples on the right hand side. If any of them shared a common attribute/value combination
further comparison was applied. In the case of the left hand side tuple having more values in
it than the right hand side, and if the right hand side was a subset of the left hand side, then
the right hand side tuple would be marked for removal.</p>
<h3 id="OptimisationEffects">4.5 Effect of Optimisation</h3>
<p>A performance evaluation between two algorithms in JRDF and Jena’s in memory
implementation was performed.</p>
<p>Jena and JRDF were run using Java 5.0 (version 1.5.0_06) under OS X 10.4.7 on a 2GHz
Intel Core Duo with 2GB of main memory. Each query was performed 3 times and an
average made. Before executing each query the Java process was restarted. In order to reduce
the impact of garbage collection on the results a maximum and initial heap size was set to
1024MB.</p>
<p>The following queries were performed on a set of FOAF data consisting of 101 282, 50 822
and 25 520 statements.</p>
<h4>Query 1</h4>
<pre>PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?mbox ?name
{
{ ?x foaf:mbox ?mbox } UNION
{ ?x foaf:mbox ?mbox . ?x foaf:name ?name }
}</pre>
<h4>Query 2</h4>
<pre>PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?mbox ?name
{
?x foaf:mbox ?mbox .
OPTIONAL { ?x foaf:name ?name } .
}</pre>

<div id="page19"/>
<h4>Query 3</h4>
<pre>PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?mbox ?name ?nick
{
?x foaf:mbox ?mbox .
OPTIONAL { ?x foaf:name ?name } .
OPTIONAL { ?x foaf:nick ?nick } .
}</pre>

<p>The two algorithms in JRDF are implementations of OPTIONAL using either a combination
of join, outer join and antijoin (labeled “JRDF” in the graph) or minimum union (labeled
“JRDF w/ Sub.” in the graph).</p>
<p><img src="Figure 2.jpg" width="703" height="371" alt="Query Performance of Various SPARQL Implementations"/><br/>
Figure 2, Query Performance of Various SPARQL Implementations</p>
<p>The difference in performance between the two implementations in JRDF can be quantified
by comparing how many times faster “JRDF w/ Sub.” is compared to “JRDF”:</p>

<div id="page20"/>
    <table border="1">
	<tr><td></td><td>~100K Statements</td><td>~50K statements</td><td>~25K statements</td></tr>
	<tr><td>Query 2</td><td>1.76</td><td>1.82</td><td>2.19</td></tr>
	<tr><td>Query 3</td><td>1.68</td><td>1.68</td><td>1.96</td></tr>
	  </table>
<p>Query 1 uses only UNION and join (“.”) and so there are no significant differences between
the two.</p>

<div id="page21"/>
<h2 id="FutureWork">5 Future Work</h2>
<h3 id="Extending">5.1 Extending the use of the Relational Model</h3>
<p>The relational model offers the ability to simplify and extend SPARQL. For example, the
two SPARQL operations: CONSTRUCT and ASK are designed to produce two alternate
result forms. The first returns an RDF graph and the second returns a true/false result
depending on if the query matches the given constraints. The creation of new operations is
not required and is suitably supported by the relational model.</p>
<p>The relational model is capable of returning results sets that allow the reconstruction of the
original graph or to create a new one based on the results returned. Likewise, with the
introduction of the true and false relation, TABLE_DEE and TABLE_DUM [<a href="#ref6">6</a>] respectively,
SPARQL’s ASK operation can be performed by performing a project over no columns. If
there are results returned a project over no columns will produce TABLE_DEE or true.</p>
<p>The set-based operation SUMMARIZE provides the same functionality as SQL’s COUNT,
SUM, MAX and MIN that “are not aggregate operators, though most of them do have the
same names as aggregate operators (SQL confuses the two notions, with unfortunate
results).” [<a href="#ref6">6</a>].</p>
<p>The SUMMARIZE operation can also be used to generate a new relation that represents a
graph based on the results of a query. Each row will produce new entries in the graph.</p>
<p>Some examples of results being turned into graphs include:</p>
      <table border="1">
	<tr><td>?s1:subject</td><td>?s2:subject</td><td>?p:predicate</td><td>object:?o1</td><td>object:?o2</td></tr>
	<tr><td>A</td><td>b</td><td>c</td><td>d</td><td>e</td></tr>
	<tr><td>A</td><td>c</td><td>c</td><td>d</td><td>e</td></tr>
	  </table>

<p>Produces the set of statements: {a, c, d}{b,c,d}{a,c,e}{b,c,e}{c, c, d}{c,c,e}</p>
      <table border="1">
	<tr><td>?foo:URI ?bar:URI</td></tr>
	<tr><td>a b</td></tr>
	  </table>

<p>Produces the set of statements: {a, a, a} {a, a, b} {a, b, a} {a, b, b} {b, a, a} {b, a, b},
{b,b,a}, {b,b,b}</p>
<p>Finally, the use of nested relations [<a href="#ref6">6</a>] may off a more efficient way of returning results than
currently provided [<a href="#ref3">3</a>].</p>
<h3 id="Optimisations">5.2 Further Optimisations</h3>
<p>If compositional semantics is chosen for SPARQL then many other optimisation techniques
could be applied. These include the original System-R optimisation but also some of the
more recent attempts to optimise and distribute left outer join and antijoin queries.</p>

<div id="page22"/>
<p>As noted, some of the optimizations given in Galindo-Legaria’s work [<a href="#ref13">13</a>] have not been
implemented. Treating relations that contain null values as a collection of non-null relations
may be used to implement the given simplifications. The effect of maintaining many relations
may, however, reduce the advantages of this approach.</p>
<p>Many of these optimisation techniques require the creation of query graphs which themselves
could be implemented using RDF. Given the right operations SPARQL queries could be
performed to find optimal query paths and could be useful in other domains.</p>
<p>The original work performed by Galindo-Legaria [<a href="#ref13">13</a>] has been criticised as being able to
handle only simplistic queries where queries that require Cartesian products or predicates that
refer to more than one table [<a href="#ref22">22</a>, <a href="#ref24">24</a>]. To improve the instances where outer joins, inner joins
an antijoins can be optimized [<a href="#ref24">24</a>]:</p>
<blockquote>
	    <p>“the normal eligibility list of each predicate with some additional information and use it to
determine the correct join order...An extended eligibility list (EEL) of a predicate p includes
all the tables needed as the input to p in order to get the correct answer”
</p>
	  </blockquote>
<p>This approach allows the efficient handling of multiple conjuncts, hyper-predicates and
Cartesian products and could be applied to SPARQL optimisation.</p>
<h3 id="SQL">5.3 A Minimum Union version of OPTIONAL Using SQL</h3>
<p>While SQL is not a natural match to RDF it is a widely deployed platform that has proven
scalability and performance characteristics and remains a key piece of infrastructure used in
organisations. With this in mind it is important to consider how this work can be applied to
SQL databases.</p>
<p>Existing work translation SPARQL to SQL [<a href="#ref2">2</a>] did not apply a minimum union approach to
implementing OPTIONAL. Larson and Zhou have applied the Galindo-Legaria approach of
translating queries into join-disjunctive form, where outer join queries are implemented as
outer unions, using SQL for view matching [<a href="#ref19">19</a>]. The results from this work have shown that
the outer join version of the queries outperformed existing approaches and could
subsequently be applied to an SQL version of OPTIONAL.</p>

<div id="page23"/>
<h2 id="Conclusion">6 Conclusion</h2>
<p>Even at this early stage of development, research has highlighted the requirement to apply a
formal model to SPARQL. The benefits of a formal model have been shown in previous
query languages and it is apparent that SPARQL would also benefit from having a formal
model. An applicable formal model must follow a number of explicit requirements including
being compatible with the RDF data model.</p>
<p>An appropriate formal model, the relational model, was used to implement parts of the RDF
querying language, SPARQL. Previous works on optimisation techniques, based on the
relational model, were used to efficiently implement the SPARQL operations OPTIONAL
and UNION. An order independent version of OPTIONAL was also considered in order to
provide a possible alternative to the current semantics of SPARQL’s OPTIONAL.</p>
<p>Relational optimisation techniques have been employed over a considerable period of time
and constitute a significant amount of existing work. It has been shown that some of these
techniques can successfully be applied to SPARQL but more work is needed. These
techniques are reliant on a method of bottom-up or compositional evaluation that is not
currently supported by SPARQL. The negative effect, of not applying this method of
evaluation, would be to hamper intuitiveness and reduce the potential for future optimisation
techniques.</p>

<div id="page24"/>
<h2 id="References">References</h2>
<dl>
      <dd>[<a name="ref1">1</a>] J. Bailey et al.., “Web and Semantic Web Query Languages: A Survey,” LNCS 3564,
2005, Norbert Eisinger, Jan Maluszynski (editor(s)),</dd>
      <dd>[<a name="ref2">2</a>] A. Chebotko et al.., Semantics Preserving SPARQL-to-SQL Query Translation for
Optional Graph Patterns, Department of Computer Science, 2006;
<a href="http://www.cs.wayne.edu/~artem/main/research/TR-DB-052006-CLJF.pdf">http://www.cs.wayne.edu/~artem/main/research/TR-DB-052006-CLJF.pdf</a></dd>
      <dd>[<a name="ref3">3</a>] K. Clark, SPARQL Protocol for RDF, World Wide Web Consortium (W3C) Candidate
Recommendation, 2006; <a href="http://www.w3.org/TR/rdf-sparql-protocol/">http://www.w3.org/TR/rdf-sparql-protocol/</a></dd>
      <dd>[<a name="ref4">4</a>] E. F. Codd, “A Relational Model for Large Shared Databanks,” Communications of the
ACM, vol. 13, no. 6, 1970, pp. 377–387.</dd>
      <dd>[<a name="ref5">5</a>] R. Cyganiak, A Relational Algebra for SPARQL, Digital Media Systems Laboratory, HP
Laboratories Bristol, Tech. Rep, HP Laboratories Bristol, Tech. Rep, 2005;
<a href="http://www.hpl.hp.com/techreports/2005/HPL-2005-170.html">http://www.hpl.hp.com/techreports/2005/HPL-2005-170.html</a></dd>
      <dd>[<a name="ref6">6</a>] C. J. Date, Database in Depth, Relational Theory for Practitioners, O’Reilly Media, Inc,
Sebastopol, California, 2005, pp. 4–10, 41–57, 86–93.</dd>
      <dd>[<a name="ref7">7</a>] C. J. Date, A Sweet Disorder, 2004; <a href="http://www.dbdebunk.com/page/page/649881.htm">http://www.dbdebunk.com/page/page/649881.htm</a></dd>
      <dd>[<a name="ref8">8</a>] C. J. Date, and H. Darwen, Databases, Types, and the Relational Model, The Third
Manifesto, Addison Wesley Longman, Inc, Reading, MA, USA, 2006.</dd>
      <dd>[<a name="ref9">9</a>] M. David, “ANSI SQL hierarchical processing can fully integrate native XML,”
SIGMOD Rec., Vol. 32, No. 1, 2003, ACM Press, pp. 41–46.</dd>
      <dd>[<a name="ref10">10</a>] F. Frasincar et al., “RAL: An Algebra for Querying RDF,” World Wide Web, Internet
and Web Information Systems (WWW), vol. 7, no. 1, 2004, pp. 83–109.</dd>
      <dd>[<a name="ref11">11</a>] C. Galindo-Legarai, “Outerjoins as Disjunctions,” Proceedings of the 1994 ACMSIGMOD
Int. Conference on Management of Data, 1994, pp. 348 – 358.</dd>
      <dd>[<a name="ref12">12</a>] C. Galindo-Legaria, Algebraic Optimization of Outerjoin Queries, Doctoral dissertation,
Harvard University, University, Cambridge, Massachusetts, 1992.</dd>
      <dd>[<a name="ref13">13</a>] C. Galindo-Legaria, and A. Rosenthal, “Outerjoin Simplification and Reordering for
Query Optimization,” ACM Transactions on Database Systems, Vol. 22, No. 1, 1997, pp.
43–74.</dd>
      <dd>[<a name="ref14">14</a>] P. Haase et al., “A Comparison of RDF Query Languages,” Proceedings of the Third
International Semantic Web Conference, Hiroshima, Japan, 2004.</dd>
      <dd>[<a name="ref15">15</a>] S. Harris, DAWG Testcases, World Wide Web Consortium (W3C), 2006;
<a href="http://www.w3.org/2001/sw/DataAccess/tests/">http://www.w3.org/2001/sw/DataAccess/tests/</a></dd>
      <dd>[<a name="ref16">16</a>] S. Harris, and N. Shadbolt, “SPARQL Query Processing with Conventional Relational
Database Systems,” WISE 2005 International Workshops, New York, NY, USA, 2005, pp.
235–244.</dd>
      <dd>[<a name="ref17">17</a>] S. Henly, “The Man Who Wasn’t There: Problems of Missing or Partially Missing Data
<a id="page25"/>
in Geoscience Databases,” International Association for Mathematical Geology, IAMG 2003,
Portsmouth, UK, 2003.</dd>
      <dd>[<a name="ref18">18</a>] G. Klyne, J. Carroll, and A. Seaborne, Resource Description Framework (RDF):
Concepts and Abstract Syntax, World Wide Web Consortium (W3C) Recommendation, 2004;
<a href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/</a></dd>
      <dd>[<a name="ref19">19</a>] P. Larson and J. Zhou, “View Matching for Outer-Join Views,” Proceedings of the 31st
VLDB Conference, Trondheim, Norway, 2005, pp. 445–456.</dd>
      <dd>[<a name="ref20">20</a>] L. Libkin, and L. Wong, “Query Languages for Bags and Aggregate Functions,” Journal
of Computer and System Sciences, vol. 55, no. 2, 1997, pp. 241–272.</dd>
      <dd>[<a name="ref21">21</a>] A. Pamukci, Outer Join in Edutella, Master’s thesis, Stockholm University, 2004.</dd>
      <dd>[<a name="ref22">22</a>] J. Perez, M. Arenas, and C. Gutierrez, Semantics and Complexity of SPARQL, 2006;
<a href="http://arxiv.org/abs/cs.DB/0605124">http://arxiv.org/abs/cs.DB/0605124</a></dd>
      <dd>[<a name="ref23">23</a>] E. Prud’hommeaux, and A. Seaborne, SPARQL Query Language for RDF, World Wide
Web Consortium (W3C) Candidate Recommendation, 2006;
<a href="http://www.w3.org/TR/2006/CR-rdf-sparql-query-20060406/">http://www.w3.org/TR/2006/CR-rdf-sparql-query-20060406/</a></dd>
      <dd>[<a name="ref24">24</a>] J. Rao et al.., “Using EELs, a practical approach to outerjoin and antijoin reordering,” 00,
Los Alamitos, CA, USA, 2001, IEEE Computer Society, pp. 585–594.</dd>
	  </dl>

  <div class="nav">
    <a href="http://validator.w3.org/check/referer"><img src=
    "http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!"
    height="31" width="88" /></a>
  </div>
  <hr />
</body>
</html>

