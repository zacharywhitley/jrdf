Package org.jrdf.drql.parser;

/*
* SPARQL Query Language for RDF SableCC grammar.
* $Id: sparql.grammar 982 2006-12-08 08:42:51Z newmana $
*/

Helpers
    character  = [0..0xFFFF];
    letter     = ['a'..'z'] | ['A'..'Z'];
    digit      = ['0'..'9'];
    tab        = 9;
    lf         = 10;
    cr         = 13;
    sl         = 47;
    whitespace = ' ' | tab | lf | cr;
    nonblank   = [33..126];
    nonquote   = [character - [39 + '\']];
    nonslash   = [[33..126] - sl];
    urlchar    = [character - '>'];

States
    def,      /* default state */
    com,      /* comment */
    esc,      /* escaping character in quoted literal with '\' */
    lit,      /* quoted literal */
    res,      /* tagged resource */
    var;      /* escaping variable name with '?' or '$' */

Tokens
    {def}                prefix      = ('PREFIX' | 'prefix');
    {def}                where       = ('WHERE' | 'where');
    {def}                union       = ('UNION' | 'union');
    {def}                optional    = ('OPTIONAL' | 'optional');

    {def, var->def}             identifier     = letter (letter | digit | '_' | '$' | '?' )*;
    {def}                       blank          = whitespace+;
    {def->com}                  hash           = '#';
    {com}                       comment        = [character - [lf + cr]];
    {com->def}                  endcomment     = (lf | cr)+;
    {def}                       comma          = ',';
    {def}                       terminator     = ';';
    {def}                       colon          = ':';
    {def}                       lpar           = '{';
    {def}                       rpar           = '}';
    {def->res}                  url            = '<';
    {res->def}                  endurl         = '>';
    {def}                       datatypeprefix = '^^';
    {def->var}                  variableprefix = ('?' | '$');
    {def}                       period         = '.';
    {def}                       number         = digit+;
    {def}                       float          = digit+ ('.' digit*) | ('.' digit+);
    {def}                       asterisk       = '*';

    {res}                       resource    = urlchar*;
    {def->lit, lit->def}        quote       = 39;  /* ' */
    {lit->esc}                  escape      = '\';
    {esc->lit}                  escapedtext = character;
    {lit}                       text        = nonquote+;

Ignored Tokens
    blank, comment, escape, endcomment, endurl, hash, url;

Productions
    start =
        {query} prolog project_clause where_clause?;

    prolog =
        {prefixdecl} prefixdecl* ;

    prefixdecl =
        {prefix} prefix identifier? colon resource ;

    project_clause =
        {variable_list} lpar variable+ rpar |
        {wildcard} lpar asterisk rpar ;

    where_clause =
        where? group_graph_pattern;

    group_graph_pattern =
        lpar graph_pattern rpar ;

    graph_pattern =
        {filtered_basic_graph_pattern} filtered_basic_graph_pattern operation_pattern? ;

    filtered_basic_graph_pattern =
        {block_of_triples} block_of_triples? ;

    block_of_triples =
        triple period? more_triples* ;

    more_triples =
        triple period? ;

    operation_pattern =
        graph_pattern_not_triples period? graph_pattern ;

    graph_pattern_not_triples =
        {optional_graph_pattern} optional_graph_pattern |
        {group_or_union_graph_pattern} group_or_union_graph_pattern ;

    optional_graph_pattern =
        optional group_graph_pattern ;

    group_or_union_graph_pattern =
        group_graph_pattern union_graph_pattern* ;

    union_graph_pattern =
        union group_graph_pattern ;

    triple =
        [subject]:resource_triple_element [predicate]:resource_triple_element [object]:object_triple_element ;

    resource_triple_element =
        {resource} resource |
        {qname} [ncname_prefix]:identifier colon [nc_name]:identifier |
        {variable} variable ;

    object_triple_element =
        {resource} resource |
        {qname} [ncname_prefix]:identifier colon [nc_name]:identifier |
        {variable} variable |
        {literal}  literal  ;


    literal =
        [opening]:quote strand* [closing]:quote;  /*datatype?;*/

    strand =
        {unescaped} text |
        {escaped}   escapedtext;

    datatype =
        datatypeprefix resource;

    variable =
        identifier comma;
