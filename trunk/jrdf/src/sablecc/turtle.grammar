Package org.jrdf.parser.turtle.parser;

/*
 * N3 SableCC grammar.
 * $Id: n3.grammar 3164 2009-10-31 20:54:58Z newmana $
 */

Helpers
  character  = [0..0xFFFF];
  letter     = ['a'..'z'] | ['A'..'Z'];
  digit      = ['0'..'9'];
  tab        = 9;
  lf         = 10;
  cr         = 13;
  dbquote    = 34;
  quote      = 39;
  sl         = 47;
  whitespace = ' ' | tab | lf | cr;
  nonblank   = [33..126];
  nonquote   = [character - [quote + '\']];
  nondbquote = [character - [dbquote + '\']];
  nonslash   = [[33..126] - sl];
  urlchar    = [character - '>'];
  echar      = 't' | 'b' | 'n' | 'r' | 'f' | '\' | dbquote | quote;
  digitstart = digit+ '.' digit* | '.' digit+ | digit+;

States
  def,      /* default state */
  qesc,     /* escaping character in quoted literal with '\' */
  dbqesc,   /* escaping character in double quoted literal with '\' */
  qlit,     /* quoted literal */
  dbqlit,   /* double quoted literal */
  lang,     /* language tag after literal */
  com;      /* comment */

Tokens
  {def}                prefix           = '@prefix';
  {def}                colon            = ':';
  {def}                base             = '@base';
  {def}                verb_a           = 'a';
  {def}                comma            = ',';
  {def}                plus             = '+';
  {def}                minus            = '-';
  {def}                true_literal     = 'true';
  {def}                false_literal    = 'false';
  {def}                start_blank_node = '[';
  {def}                end_blank_node   = ']';
  {def}                start_items      = '(';
  {def}                end_items        = ')';

  {def->com}                      hash           = '#';
  {com}                           comment        = [character - [lf + cr]];
  {com->def}                      endcomment     = (lf | cr)+;
  {def}                           blank          = whitespace+;

  {def}                           node_separator  = ';';
  {def}                           stmt_separator  = '.';

  {def}                           blank_node_prefix = '_:';
  {def}                           empty_blank_node  = '[]';
  {def}                           prefix_name    = letter (letter | digit | '_' | '$' | '?' )*;

  {def}                           identifier     = letter (letter | digit | '_' | '$' | '?' )*;
  {def}                           resource       = '<' urlchar* '>';

  {def}                           integer        = digit+;
  {def}                           decimal        = digit+ '.' digit* | '.' digit+;
  {def}                           double         = digitstart ('e' | 'E') digit+;

  {def->qlit, qlit->def}          quote          = quote;
  {qlit}                          qtext          = nonquote+;
  {qlit->qesc}                    qescape        = '\';
  {qesc->qlit}                    qescapedtext   = character;

  {def->dbqlit, dbqlit->def}      dbquote        = dbquote;
  {dbqlit}                        dbqtext        = nondbquote+;
  {dbqlit->dbqesc}                dbqescape      = '\';
  {dbqesc->dbqlit}                dbqescapedtext = character;

  {def->lang}                     at             = '@';
  {lang->def}                     langtag        = letter+ ('-' | letter)*;

  {def}                           datatypeprefix = '^^';

Ignored Tokens
  blank, comment, qescape, dbqescape, endcomment, hash;

Productions
  start =
    {statements} statement*;

  statement =
    {directive_stmt} directive stmt_separator |
    {triples_stmt} triples stmt_separator ;

  directive =
    {prefix_id_directive} prefix prefix_name? colon resource |
    {base_directive} base resource;

  triples =
    subject predicate_object_list;

  predicate_object_list =
    verb object_list verb_object_list* node_separator?;

  verb =
    {predicate_verb} predicate |
    {a_verb} verb_a;

  object_list =
    object more_objects*;

  more_objects =
    comma object;

  verb_object_list =
    node_separator verb object_list;

  subject =
    {subject_resource} iri_ref_or_prefixed_name |
    {subject_blank} blank_node;

  predicate =
    {predicate_resource} iri_ref_or_prefixed_name;

  object =
    {object_resource} iri_ref_or_prefixed_name |
    {object_blank} blank_node |
    {object_literal} literal;

  blank_node =
    {blank_node_with_id} blank_node_prefix identifier |
    {empty_blank_node} empty_blank_node |
    {node_predicate_object_list} start_blank_node predicate_object_list end_blank_node |
    {collection} collection;

  iri_ref_or_prefixed_name =
    {iri_ref} resource |
    {prefixed_name} qname_element;

  qname_element =
      {qname} [ncname_prefix]:identifier colon [nc_name]:identifier;

  literal =
    {rdf_literal} rdf_literal |
    {numeric_literal} numeric_literal |
    {boolean_literal} boolean_literal;

  rdf_literal =
    {untyped_literal} literal_value |
    {lang_literal} literal_value at [language]:langtag |
    {typed_literal} literal_value datatype ;

  literal_value =
      {quoted_literal} [opening_quote]:quote quoted_strand* [closing_quote]:quote |
      {db_quoted_literal} [opening_db_quote]:dbquote db_quoted_strand* [closing_db_quote]:dbquote;

  quoted_strand =
    {quoted_unescaped} qtext |
    {quoted_escaped} qescapedtext;

  db_quoted_strand =
    {db_quoted_unescaped} dbqtext |
    {db_quoted_escaped} dbqescapedtext;

  datatype =
    {qname_datatype} datatypeprefix qname_element |
    {resource_datatype} datatypeprefix resource;

  numeric_literal =
    {unsigned_numeric_literal} unsigned_numeric_literal |
    {positive_numeric_literal} plus unsigned_numeric_literal |
    {negative_numeric_literal} minus unsigned_numeric_literal;

  unsigned_numeric_literal =
    {integer} integer |
    {decimal} decimal |
    {double} double;

  boolean_literal =
    {true} true_literal |
    {false} false_literal ;

  collection =
    {collection_items} start_items items? end_items;

  items =
    {item_objects} object+;
